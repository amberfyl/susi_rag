## Chapter 1: Introduction

### 1.1 Brief introduction:
**SUSI â€“ A Bridge to Simplify & Enhance H/W & Application Implementation Efficiency**

SUSI (Secured & Unified Smart Interface) is a suite of Software APIs (Application Programming Interfaces) designed to simplify hardware access for application developers. It provides a unified interface for interacting with various hardware components, eliminating the need to study complex hardware specifications and write low-level drivers.
SUSI full name : Secure and Unified Smart Interface.
SUSI (Secured & Unified Smart Interface) is a suite of Software APIs (Application Programming Interfaces) designed to simplify hardware access for application developers. It provides a unified interface for interacting with various hardware components, eliminating the need to study complex hardware specifications and write low-level drivers.
Including GPIO Functions, SMBus Functions, I2C Functions, Watchdog Functions, Hardware Monitor Functions, Backlight Control Functions, Storage Functions, Thermal Protection Functions.
Susi4.h header file includes the API declaration, constants and flags that are required for programming.

### 1.2 Benefits
SUSI (Secured & Unified Smart Interface) is a suite of Software APIs (Application Programming Interfaces) designed to simplify hardware access for application developers. It provides a unified interface for interacting with various hardware components, eliminating the need to study complex hardware specifications and write low-level drivers.
It offers several advantages for embedded system developers:

* **Faster Time to Market:** The unified API simplifies hardware access, reducing development time and effort.
* **Reduced Project Effort:** SUSI provides pre-built drivers and APIs, eliminating the need to write them from scratch.
* **Enhanced Hardware Platform Reliability:** SUSI's trusted solution ensures compatibility and stability, enhancing platform reliability.
* **Flexible Upgrade Possibilities:** Upgrading SUSI to newer versions provides access to new features and functionalities.
* **Backward compatibility:** SUSI maintains backward compatibility with previous versions, ensuring existing applications continue to function.

### 1.3 Environment Requirements : Operating Systems

SUSI supports a wide range of operating systems, including:

* Windows XP Embedded
* Windows XP 32-bit
* Windows 7 (x86 / x64)
* WES7 (x86 / x64)
* Windows 8 Desktop (x86 / x64)
* Windows 10 (x64)
* Windows 11 (x64)
* Windows CE 5 / 6 / 7
* RISC Yocto 2.1
* Ubuntu 20.04
* Ubuntu 22.04
* Linux (Project based, request from your local FAE)
* Android (Project based, request from your local FAE)
* QNX (Project based, request from your local FAE)
* VxWorks (Project based, request from your local FAE) 



## Chapter 2: SUSI Definition

This chapter details the structure and functionalities provided by the SUSI (Secured & Unified Smart Interface) API, including status codes, IDs, and item IDs.

### 2.1 Status Codes( part 1)
SUSI API functions return status codes to indicate the outcome of an operation. Here's a list of possible status codes:
**SUSI_STATUS_NOT_INITIALIZED:**
* Value: `0xFFFFFFFF`
* Description: The SUSI API library is not yet initialized or initialization was unsuccessful. You need to call `SusiLibInitialize` before using any other SUSI API functions.
* Action: Call `SusiLibInitialize`.

**SUSI_STATUS_INITIALIZED:**
* Value: `0xFFFFFFFE`
* Description: The SUSI API library is successfully initialized.
* Action: None.

**SUSI_STATUS_ALLOC_ERROR:**
* Value: `0xFFFFFFFD`
* Description: Memory allocation error. This indicates that the system was unable to allocate the required memory for the operation.
* Action: Free up memory and try again. Consider checking for memory leaks in your application or increasing available system memory.

**SUSI_STATUS_DRIVER_TIMEOUT:**
* Value: `0xFFFFFFFC`
* Description: Timeout occurred in the driver. This is usually caused by a hardware or software semaphore timeout, meaning the driver did not receive a response within the expected timeframe.
* Action: Retry the operation. If the issue persists, investigate potential hardware issues or driver conflicts.

**SUSI_STATUS_INVALID_PARAMETER:**
* Value: `0xFFFFFEFF`
* Description: One or more parameters passed to the SUSI API function are outside the defined range or are invalid.
* Action: Verify the function parameters against the API documentation to ensure they are within the acceptable range and format.

**SUSI_STATUS_INVALID_BLOCK_ALIGNMENT:**
* Value: `0xFFFFFEFE`
* Description: Incorrect block alignment. This occurs when data is not aligned to the required memory boundaries, potentially leading to performance issues or errors.
* Action: Use the input and output specifications provided in the API documentation to correctly align the data.

**SUSI_STATUS_INVALID_BLOCK_LENGTH:**
* Value: `0xFFFFFEFD`
* Description: The block length is too long. This indicates that the requested data block size exceeds the maximum allowed by the hardware or API.
* Action: Use the alignment capabilities information provided by the API to determine the maximum allowed block length and adjust your request accordingly.

### 2.1 Status Codes( part 2)
**SUSI_STATUS_INVALID_DIRECTION:**
* Value: `0xFFFFFEFC`
* Description: Trying to set GPIOs to an unsupported direction. For example, attempting to set a GPIO pin configured as input to output.
* Action: Refer to the input and output specifications for the specific GPIO pin in the API documentation to ensure you are setting the correct direction.

**SUSI_STATUS_INVALID_BITMASK:**
* Value: `0xFFFFFEFB`
* Description: The bitmask selects unsupported bits/GPIOs for the current ID. This means the bitmask contains bits that correspond to GPIO pins not supported by the selected ID.
* Action: Consult the input and output specifications for the specific ID in the API documentation to determine the supported GPIO pins and adjust your bitmask accordingly.

**SUSI_STATUS_RUNNING:**
* Value: `0xFFFFFEFA`
* Description: Watchdog timer is already running. This indicates an attempt to start the watchdog timer while it is already active.
* Action: Call `SusiWDogStop` to stop the existing watchdog timer before attempting to start it again.

**SUSI_STATUS_UNSUPPORTED:**
* Value: `0xFFFFFCFF`
* Description: The requested function or ID is not supported by the hardware environment or the current API version.
* Action: Verify that the requested functionality is supported by the hardware and API version being used. Consider alternative approaches if the functionality is not available.

**SUSI_STATUS_NOT_FOUND:**
* Value: `0xFFFFFBFF`
* Description: The selected device was not found. This indicates that the specified device ID does not correspond to a valid device on the system.
* Action: Verify the device ID and ensure that the device is properly connected and recognized by the system.

**SUSI_STATUS_TIMEOUT:**
* Value: `0xFFFFFBFE`
* Description: The device did not respond after several retries. This indicates a communication issue with the device, potentially due to a hardware malfunction or connection problem.
* Action: Check the device connection and verify that it is powered on and functioning correctly. Consider resetting the device or the system.

**SUSI_STATUS_BUSY_COLLISION:**
* Value: `0xFFFFFBFD`
* Description: The selected device or ID is busy, or a data collision was detected on the bus. This indicates a conflict in accessing the device, potentially due to simultaneous access attempts.
* Action: Retry the operation after a short delay. If the issue persists, investigate potential resource contention issues or driver conflicts.

**SUSI_STATUS_NORESPONSE:**
* Value: `0xFFFFFBFC`
* Description: The selected device is not responding. This indicates a complete lack of communication with the device, potentially due to a hardware failure or incorrect device ID.
* Action: Verify the device connection, power, and functionality. Check the device ID and ensure it is correct.

**SUSI_STATUS_NOACK:**
* Value: `0xFFFFFBFB`
* Description: The selected device did not acknowledge the request. This indicates a communication breakdown where the device received the request but did not send an acknowledgment.
* Action: Check the device connection and verify its functionality. Investigate potential communication issues or driver problems.


### 2.1 Status Codes( part 3)
**SUSI_STATUS_LOCKFAIL:**
* Value: `0xFFFFFBFA`
* Description: Failed to acquire a spin lock or mutex lock. This indicates a synchronization issue where the API was unable to obtain exclusive access to a shared resource.
* Action: This error usually suggests a problem within the SUSI API or driver. Consider updating the driver or API version. If the issue persists, contact technical support.

**SUSI_STATUS_DEVICE_ERROR:**
* Value: `0xFFFFFBF9`
* Description: The selected device encountered an error. This is a generic error indicating a problem with the device itself.
* Action: Check the device's status and error logs for more specific information about the error. Consider resetting the device or checking for hardware issues.

**SUSI_STATUS_READ_ERROR:**
* Value: `0xFFFFFAFF`
* Description: An error occurred during a read operation. This indicates a problem reading data from the device or memory location.
* Action: Retry the operation. If the issue persists, investigate potential hardware issues, connection problems, or data corruption.

**SUSI_STATUS_WRITE_ERROR:**
* Value: `0xFFFFFAFE`
* Description: An error occurred during a write operation. This indicates a problem writing data to the device or memory location.
* Action: Retry the operation. If the issue persists, investigate potential hardware issues, connection problems, or write protection mechanisms.

**SUSI_STATUS_ACCESS_ERROR:**
* Value: `0xFFFFFAFD`
* Description: An error occurred during an access operation. This is a generic error indicating a problem accessing the device or memory location.
* Action: Retry the operation. If the issue persists, investigate potential hardware issues, connection problems, or access permission errors.

**SUSI_STATUS_MORE_DATA:**
* Value: `0xFFFFF9FF`
* Description: The amount of data available exceeds the buffer size. Storage buffer overflow was prevented. This occurs when the read data is larger than the provided buffer.
* Action: Increase the buffer size to accommodate the larger data size or reduce the requested data length.

**SUSI_STATUS_ERROR:**
* Value: `0xFFFFF0FF`
* Description: A generic error occurred. No further details are available.
* Action: Check system logs and application output for potential clues about the error. Consider increasing logging verbosity for more detailed information.

**SUSI_STATUS_SUCCESS:**
* Value: `0`
* Description: The operation completed successfully.
* Action: None.


## Chapter 3: SUSI API

This chapter provides a detailed description of the SUSI API functions, categorized by their functionalities.


### 3.1.1 SusiLibInitialize

```c
uint32_t SUSI_API SusiLibInitialize(void)
```

**Description:**

Initializes the SUSI API library. This function must be called before using any other SUSI API functions.

**Parameters:**

None

**Return Status Code:**

* `SUSI_STATUS_INITIALIZED` (Value: `0xFFFFFFFE`): Library is already initialized.
* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Initialization failed.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Initialization successful.

### 3.1.2 SusiLibUninitialize

```c
uint32_t SUSI_API SusiLibUninitialize(void)
```

**Description:**

Uninitializes the SUSI API library. This function should be called before program exit to release resources held by the library.

**Parameters:**

None

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Uninitialization successful.


### 3.2.1 SusiBoardGetValue

```c
uint32_t SUSI_API SusiBoardGetValue(uint32_t Id, uint32_t *pValue)
```
(To know SMBUS support or not. To know I2C support or not. )

**Description:**
Retrieves numerical information about the hardware platform.Retrieve various hardware info and monitoring data.
Uese this function to know if a specific hardware feature is supported by SUSI on user platform.


**Parameters:**

* `Id`: Selects the target value to retrieve. See the list below for possible `Id` values and their descriptions.
* `pValue`: Pointer to a buffer that receives the retrieved value. The size of the buffer depends on the `Id` parameter. For single-value IDs, a `uint32_t` pointer is sufficient. For multi-value IDs (e.g., IP address), an array of appropriate size should be used.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pValue` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Value retrieved successfully.

Using Below ID in SusiBoardGetValue and getting the corresponding value described behind each item.

**Board Information Value IDs:**

* `SUSI_ID_GET_SPEC_VERSION` (Value: `0x00000000`): API specification version.
* `SUSI_ID_BOARD_BOOT_COUNTER_VAL` (Value: `0x00000001`): Boot counter (number of system boots). Unit: boots.
* `SUSI_ID_BOARD_RUNNING_TIME_METER_VAL` (Value: `0x00000002`): Running time meter (total system uptime). Unit: hours.
* `SUSI_ID_BOARD_PNPID_VAL` (Value: `0x00000003`): Vendor PNPID (unique identifier for the board vendor).
* `SUSI_ID_BOARD_PLATFORM_REV_VAL` (Value: `0x00000004`): Platform revision (hardware iteration).
* `SUSI_ID_BOARD_DRIVER_VERSION_VAL` (Value: `0x00010000`): Driver version (SUSI driver software version).
* `SUSI_ID_BOARD_LIB_VERSION_VAL` (Value: `0x00010001`): Library version (SUSI API library version).
* `SUSI_ID_BOARD_FIRMWARE_VERSION_VAL` (Value: `0x00010002`): Firmware version (software version embedded in the hardware).
* `SUSI_ID_SMBUS_SUPPORTED` (Value: `0x00030000`): Mask flags for supported SMBus devices. See "SMBus and I2C Device IDs" for details.
* `SUSI_ID_I2C_SUPPORTED` (Value: `0x00030100`): Mask flags for supported I2C devices. See "SMBus and I2C Device IDs" for details.

### 3.2.1 SusiBoardGetValue (part2) in c code
```c
uint32_t SUSI_API SusiBoardGetValue(uint32_t Id, uint32_t *pValue)
```
(To get fan speed)
Using Below ID in SusiBoardGetValue and getting the corresponding value described behind each item.Including fan speed in RPM, temperature, voltage, etc.



**Hardware Monitor (HWM) Value IDs:**

* `SUSI_ID_HWM_TEMP_CPU` (Value: `0x00020000`): CPU temperature. Unit: 0.1 Kelvin.
* `SUSI_ID_HWM_TEMP_CHIPSET` (Value: `0x00020001`): Chipset temperature. Unit: 0.1 Kelvin.
* `SUSI_ID_HWM_TEMP_SYSTEM` (Value: `0x00020002`): System temperature. Unit: 0.1 Kelvin.
* `SUSI_ID_HWM_TEMP_CPU2` (Value: `0x00020003`): Second CPU temperature (if applicable). Unit: 0.1 Kelvin.
* `SUSI_ID_HWM_TEMP_OEM0` (Value: `0x00020004`) to `SUSI_ID_HWM_TEMP_OEM5` (Value: `0x00020009`): Other temperature sensors. Unit: 0.1 Kelvin.
* `SUSI_ID_HWM_VOLTAGE_VCORE` (Value: `0x00021000`): CPU core voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_VCORE2` (Value: `0x00021001`): Second CPU core voltage (if applicable). Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_2V5` (Value: `0x00021002`): 2.5V rail voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_3V3` (Value: `0x00021003`): 3.3V rail voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_5V` (Value: `0x00021004`): 5V rail voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_12V` (Value: `0x00021005`): 12V rail voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_5VSB` (Value: `0x00021006`): 5V standby voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_3VSB` (Value: `0x00021007`): 3V standby voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_VBAT` (Value: `0x00021008`): CMOS battery voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_5NV` (Value: `0x00021009`): -5V rail voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_12NV` (Value: `0x0002100A`): -12V rail voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_VTT` (Value: `0x0002100B`): DIMM voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_24V` (Value: `0x0002100C`): 24V rail voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_DC` (Value: `0x0002100D`): DC input voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_DCSTBY` (Value: `0x0002100E`): DC standby voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_OEM3` (Value: `0x0002100F`): Other voltage sensor. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_OEM0` (Value: `0x00021010`) to `SUSI_ID_HWM_VOLTAGE_OEM3` (Value: `0x00021013`): Other voltage sensors. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_1V05` (Value: `0x00021014`): 1.05V rail voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_1V5` (Value: `0x00021015`): 1.5V rail voltage. Unit: millivolt.
* `SUSI_ID_HWM_VOLTAGE_1V8` (Value: `0x00021016`): 1.8V rail voltage. Unit: millivolt.
* `SUSI_ID_HWM_FAN_CPU` (Value: `0x00022000`): CPU fan speed. Unit: RPM.
* `SUSI_ID_HWM_FAN_SYSTEM` (Value: `0x00022001`): System fan speed. Unit: RPM.
* `SUSI_ID_HWM_FAN_CPU2` (Value: `0x00022002`): Second CPU fan speed (if applicable). Unit: RPM.
* `SUSI_ID_HWM_FAN_OEM0` (Value: `0x00022003`) to `SUSI_ID_HWM_FAN_OEM6` (Value: `0x00022009`): Other fan speed sensors. Unit: RPM.
* `SUSI_ID_HWM_CURRENT_OEM0` (Value: `0x00023000`) to `SUSI_ID_HWM_CURRENT_OEM2` (Value: `0x00023002`): Current sensors.
* `SUSI_ID_HWM_CASEOPEN_OEM0` (Value: `0x00024000`) to `SUSI_ID_HWM_CASEOPEN_OEM2` (Value: `0x00024002`): Case open sensors.


### 3.2.2 SusiBoardGetStringA

```c
uint32_t SUSI_API SusiBoardGetStringA(uint32_t Id, char *pBuffer, uint32_t *pBufLen)
```

**Description:**

Retrieves text information about the hardware platform.For example BIOS revision.

**Parameters:**

* `Id`: Selects the target string to retrieve. See the list below for possible `Id` values and their descriptions.
* `pBuffer`: Pointer to a buffer that receives the retrieved string.
* `pBufLen`: Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by `pBuffer`. When the function returns, this variable contains the size of the data copied to `pBuffer`, including the terminating null character.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pBufLen` is NULL, or `pBufLen` is not NULL, `*pBufLen` is not 0, and `pBuffer` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_MORE_DATA` (Value: `0xFFFFF9FF`): The buffer is too small to hold the retrieved string. `*pBufLen` will be set to the required buffer size.
* `SUSI_STATUS_SUCCESS` (Value: `0`): String retrieved successfully.

Using Below ID in SusiBoardGetStringA and getting the corresponding value described behind each item.
**Board Information String IDs:**

* `SUSI_ID_BOARD_MANUFACTURER_STR` (Value: `0`): Board manufacturer name.
* `SUSI_ID_BOARD_NAME_STR` (Value: `1`): Board name.
* `SUSI_ID_BOARD_REVISION_STR` (Value: `2`): Board revision.
* `SUSI_ID_BOARD_SERIAL_STR` (Value: `3`): Board serial number.
* `SUSI_ID_BOARD_BIOS_REVISION_STR` (Value: `4`): Board BIOS revision.
* `SUSI_ID_BOARD_HW_REVISION_STR` (Value: `5`): Hardware revision.
* `SUSI_ID_BOARD_PLATFORM_TYPE_STR` (Value: `6`): Platform type.
* `SUSI_ID_BOARD_EC_FW_STR` (Value: `7`): Firmware name.



### 3.3.1 SusiVgaGetCaps

```c
uint32_t SUSI_API SusiVgaGetCaps(uint32_t Id, uint32_t ItemId, uint32_t *pValue)
```

**Description:**

Retrieves VGA capabilities.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `ItemId`: Selects the target capability. See "VGA Capabilities Item IDs" for possible values.
* `pValue`: Pointer to a buffer that receives the target capability value.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pValue` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or `ItemId`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Capability retrieved successfully.

**VGA Capabilities Item IDs:**

* `SUSI_ID_VGA_BRIGHTNESS_MAXIMUM` (Value: `0x00010000`): Maximum backlight brightness value.
* `SUSI_ID_VGA_BRIGHTNESS_MINIMUM` (Value: `0x00010001`): Minimum backlight brightness value.


**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.

**Get the backlight brightness range:** Use the `SusiVgaGetCaps` function with the `SUSI_ID_VGA_BRIGHTNESS_MAXIMUM` and `SUSI_ID_VGA_BRIGHTNESS_MINIMUM` parameters to get the maximum and minimum values for the backlight brightness.

```c
uint32_t maxBrightness, minBrightness;
SusiVgaGetCaps(SUSI_ID_BACKLIGHT_1, SUSI_ID_VGA_BRIGHTNESS_MAXIMUM, &maxBrightness);
SusiVgaGetCaps(SUSI_ID_BACKLIGHT_1, SUSI_ID_VGA_BRIGHTNESS_MINIMUM, &minBrightness);
```


### 3.3.2 SusiVgaGetBacklightEnable

```c
uint32_t SUSI_API SusiVgaGetBacklightEnable(uint32_t Id, uint32_t *pEnable)
```

**Description:**

Retrieves the current backlight enable state for the specified flat panel display.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `pEnable`: Pointer to a buffer that receives the current backlight enable state. See "Backlight Enable Values" for possible values.

**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.

**Backlight Enable Values:**

* `SUSI_BACKLIGHT_SET_ON`: Enables the backlight.
* `SUSI_BACKLIGHT_SET_OFF`: Disables the backlight.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pEnable` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Backlight enable state retrieved successfully.

### 3.3.3 SusiVgaSetBacklightEnable

```c
uint32_t SUSI_API SusiVgaSetBacklightEnable(uint32_t Id, uint32_t Enable)
```

**Description:**

Enables or disables the backlight of the selected flat panel display.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `Enable`: Backlight enable option. See "Backlight Enable Values" for possible values.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Backlight enable state set successfully.

**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.

**Backlight Enable Values:**

* `SUSI_BACKLIGHT_SET_ON`: Enables the backlight.
* `SUSI_BACKLIGHT_SET_OFF`: Disables the backlight.


### 3.3.4 SusiVgaGetBacklightBrightness

```c
uint32_t SUSI_API SusiVgaGetBacklightBrightness(uint32_t Id, uint32_t *pBright)
```

**Description:**

Retrieves the current backlight brightness value of the selected flat panel display.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `pBright`: Pointer to a buffer that receives the current backlight brightness value.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pBright` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Backlight brightness value retrieved successfully.

**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.


### 3.3.5 SusiVgaSetBacklightBrightness

```c
uint32_t SUSI_API SusiVgaSetBacklightBrightness(uint32_t Id, uint32_t Bright)
```

**Description:**

Sets the backlight brightness value of the selected flat panel display.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `Bright`: Backlight brightness value. The valid range for this value can be obtained using `SusiVgaGetCaps` with `SUSI_ID_VGA_BRIGHTNESS_MAXIMUM` and `SUSI_ID_VGA_BRIGHTNESS_MINIMUM`.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `Bright` is outside the valid range.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Backlight brightness value set successfully.

**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.



### 3.3.6 SusiVgaGetBacklightLevel

```c
uint32_t SUSI_API SusiVgaGetBacklightLevel(uint32_t Id, uint32_t *pLevel)
```

**Description:**

Retrieves the current backlight brightness level of the selected flat panel display.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `pLevel`: Pointer to a buffer that receives the current backlight brightness level. See "Brightness Level Range Definition" for possible values.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pLevel` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Backlight brightness level retrieved successfully.

**Brightness Level Range Definition:**

* `SUSI_BACKLIGHT_LEVEL_MAXIMUM`: Maximum backlight level is 9.
* `SUSI_BACKLIGHT_LEVEL_MINIMUM`: Minimum backlight level is 0.

**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.

### 3.3.7 SusiVgaSetBacklightLevel

```c
uint32_t SUSI_API SusiVgaSetBacklightLevel(uint32_t Id, uint32_t Level)
```

**Description:**

Sets the backlight brightness level of the selected flat panel display.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `Level`: Backlight brightness level. See "Brightness Level Range Definition" for possible values.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `Level` is greater than `SUSI_BACKLIGHT_LEVEL_MAXIMUM`.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Backlight brightness level set successfully.

**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.

**Brightness Level Range Definition:**

* `SUSI_BACKLIGHT_LEVEL_MAXIMUM`: Maximum backlight level is 9.
* `SUSI_BACKLIGHT_LEVEL_MINIMUM`: Minimum backlight level is 0.


### 3.3.8 SusiVgaGetPolarity

```c
uint32_t SUSI_API SusiVgaGetPolarity(uint32_t Id, uint32_t *pPolarity)
```

**Description:**

Retrieves the current backlight polarity of the selected flat panel display.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `pPolarity`: Pointer to a buffer that receives the current backlight polarity. See "Brightness Polarity Definition" for possible values.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pPolarity` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Backlight polarity retrieved successfully.

**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.

**Brightness Polarity Definition:**

* `SUSI_BACKLIGHT_POLARITY_ON`: Backlight signal polarity is ON.
* `SUSI_BACKLIGHT_POLARITY_OFF`: Backlight signal polarity is OFF.


### 3.3.9 SusiVgaSetPolarity

```c
uint32_t SUSI_API SusiVgaSetPolarity(uint32_t Id, uint32_t Polarity)
```

**Description:**

Sets the backlight polarity of the selected flat panel display.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `Polarity`: Polarity state. See "Brightness Polarity Definition" for possible values.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Backlight polarity set successfully.

**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.

**Brightness Polarity Definition:**

* `SUSI_BACKLIGHT_POLARITY_ON`: Backlight signal polarity is ON.
* `SUSI_BACKLIGHT_POLARITY_OFF`: Backlight signal polarity is OFF.



### 3.3.10 SusiVgaGetFrequency

```c
uint32_t SUSI_API SusiVgaGetFrequency(uint32_t Id, uint32_t *pFrequency)
```

**Description:**

Retrieves the current backlight frequency of the selected flat panel display.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `pFrequency`: Pointer to a buffer that receives the current backlight frequency (in Hz).

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pFrequency` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Backlight frequency retrieved successfully.

**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.


### 3.3.11 SusiVgaSetFrequency

```c
uint32_t SUSI_API SusiVgaSetFrequency(uint32_t Id, uint32_t Frequency)
```

**Description:**

Sets the backlight frequency of the selected flat panel display.One of Backlight Functions(This function subset facilitates backlight control for integrated flat panel displays, typically LVDS.). 

**Parameters:**

* `Id`: Selects the target backlight device. See "Backlight IDs" for possible values.
* `Frequency`: Frequency value (in Hz).

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Backlight frequency set successfully.

**Backlight IDs:**

* `SUSI_ID_BACKLIGHT_1` (Value: `0`): Backlight for Local Flat Panel 1.
* `SUSI_ID_BACKLIGHT_2` (Value: `1`): Backlight for Local Flat Panel 2.
* `SUSI_ID_BACKLIGHT_3` (Value: `2`): Backlight for Local Flat Panel 3.



### 3.4.1 SusiI2CGetCaps

```c
uint32_t SUSI_API SusiI2CGetCaps(uint32_t Id, uint32_t ItemId, uint32_t *pValue)
```

**Description:** Retrieves the capabilities of the I2C controller specified by `Id`.

**Parameters:**

* **`Id`**: Selects the target I2C controller. Refer to the "I2C ID" list below for possible values.
* **`ItemId`**: Selects the specific capability to query. Currently, only `SUSI_ID_I2C_MAXIMUM_BLOCK_LENGTH` is supported.
* **`pValue`**: A pointer to a `uint32_t` variable that will receive the value of the requested capability.

**I2C ID:**

* `SUSI_ID_I2C_EXTERNAL` (Value: `0`): Represents the main I2C host controller on the platform.
* `SUSI_ID_I2C_OEM0` (Value: `1`): Represents an additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM1` (Value: `2`): Represents another additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM2` (Value: `3`): Represents yet another additional I2C host controller (OEM-specific).

**I2C Capabilities Item ID:**

* `SUSI_ID_I2C_MAXIMUM_BLOCK_LENGTH` (Value: `0x00000000`): Retrieves the maximum block length supported by the I2C controller in bytes.

**Return Status Code:**

* `SUSI_STATUS_SUCCESS` (0): The operation completed successfully.
* `SUSI_STATUS_NOT_INITIALIZED` (0xFFFFFFFF): The SUSI API library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (0xFFFFFEFF): An invalid parameter was passed to the function (e.g., `pValue` is `NULL`).
* `SUSI_STATUS_UNSUPPORTED` (0xFFFFFCFF): The specified `Id` or `ItemId` is not supported by the platform.

**Example Usage:**

```c
uint32_t maxBlockLength;
//Supporting both standard 7-bit and 10-bit slave addressing modes.
uint32_t result = SusiI2CGetCaps(SUSI_ID_I2C_EXTERNAL, SUSI_ID_I2C_MAXIMUM_BLOCK_LENGTH, &maxBlockLength);
if (result == SUSI_STATUS_SUCCESS)
{
    // maxBlockLength now contains the maximum I2C block length.
}
```

### 3.4.2 SusiI2CWriteReadCombine

```c
uint32_t SUSI_API SusiI2CWriteReadCombine(uint32_t Id, uint8_t Addr, uint8_t *pWBuffer, uint32_t WriteLen, uint8_t *pRBuffer, uint32_t ReadLen)
```

**Description:** Performs a combined write and read operation on the I2C bus. This function allows you to write data to an I2C device and then immediately read data from the same device without releasing the bus.

**Parameters:**

* **`Id`**: Selects the target I2C controller. Refer to the "I2C ID" list in section 3.4.1 for possible values.
* **`Addr`**: The 7-bit I2C slave address of the target device. The least significant bit (LSB) of the address, which indicates read or write, is ignored.
* **`pWBuffer`**: A pointer to a buffer containing the data to be written to the I2C device. This parameter can be `NULL` if no write operation is required.
* **`WriteLen`**: The size, in bytes, of the data to be written. This parameter is ignored if `pWBuffer` is `NULL`.
* **`pRBuffer`**: A pointer to a buffer that will receive the data read from the I2C device. This parameter can be `NULL` if no read operation is required.
* **`ReadLen`**: The size, in bytes, of the buffer pointed to by `pRBuffer`. This parameter is ignored if `pRBuffer` is `NULL`.

**Return Status Code:**

* `SUSI_STATUS_SUCCESS` (0): The combined write and read operation completed successfully.
* `SUSI_STATUS_NOT_INITIALIZED` (0xFFFFFFFF): The SUSI API library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (0xFFFFFEFF): An invalid parameter was passed to the function (e.g., both `WriteLen` and `ReadLen` are 0, or a buffer pointer is `NULL` when its corresponding length is greater than 0).
* `SUSI_STATUS_UNSUPPORTED` (0xFFFFFCFF): The specified `Id` is not supported by the platform.
* `SUSI_STATUS_BUSY_COLLISION` (0xFFFFFBFD): The I2C bus is busy, or a data collision was detected.
* `SUSI_STATUS_TIMEOUT` (0xFFFFFBFE): A timeout occurred due to clock stretching by the I2C device.
* `SUSI_STATUS_NOT_FOUND` (0xFFFFFBFF): The I2C device did not acknowledge its address.
* `SUSI_STATUS_WRITE_ERROR` (0xFFFFFAFE): An error occurred during the write operation.

**I2C ID:**

* `SUSI_ID_I2C_EXTERNAL` (Value: `0`): Represents the main I2C host controller on the platform.
* `SUSI_ID_I2C_OEM0` (Value: `1`): Represents an additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM1` (Value: `2`): Represents another additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM2` (Value: `3`): Represents yet another additional I2C host controller (OEM-specific).

**Example Usage:**

```c
uint8_t writeData[2] = {0x01, 0x02};
uint8_t readData[4];
uint32_t result = SusiI2CWriteReadCombine(SUSI_ID_I2C_EXTERNAL, 0x50, writeData, 2, readData, 4);
if (result == SUSI_STATUS_SUCCESS)
{
    // Data was successfully written and read from the I2C device.
}
```

### 3.4.3 SusiI2CReadTransfer

```c
uint32_t SUSI_API SusiI2CReadTransfer(uint32_t Id, uint32_t Addr, uint32_t Cmd, uint8_t *pBuffer, uint32_t ReadLen)
```

**Description:** Reads data from a specific register within the selected I2C device.

**Parameters:**

* **`Id`**: Selects the target I2C controller. Refer to the "I2C ID" list .
* **`Addr`**: The encoded 7-bit or 10-bit I2C slave address of the target device.
* **`Cmd`**: The encoded I2C command or register index to read from. Refer to the "I2C Command Encoding" for encoding details.
* **`pBuffer`**: A pointer to a buffer that will receive the data read from the I2C device.
* **`ReadLen`**: The size, in bytes, of the buffer pointed to by `pBuffer`.

**I2C ID:**

* `SUSI_ID_I2C_EXTERNAL` (Value: `0`): Represents the main I2C host controller on the platform.
* `SUSI_ID_I2C_OEM0` (Value: `1`): Represents an additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM1` (Value: `2`): Represents another additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM2` (Value: `3`): Represents yet another additional I2C host controller (OEM-specific).

**I2C Command Encoding:**

* **Standard Command:** A single byte command.
* **Extended Command:** A word command encoded by ORing the command value with `0x80000000`. For example, the command `0xFABC` would be encoded as `0x8000FABC`.
* **No Command:**  Use `0x4000xxxx` (where `xxxx` can be any value) to indicate that no command is being used. The command parameter will be ignored in this case.


**Return Status Code:**

* `SUSI_STATUS_SUCCESS` (0): The read operation completed successfully.
* `SUSI_STATUS_NOT_INITIALIZED` (0xFFFFFFFF): The SUSI API library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (0xFFFFFEFF): An invalid parameter was passed to the function (e.g., `pBuffer` is `NULL` or `ReadLen` is 0).
* `SUSI_STATUS_UNSUPPORTED` (0xFFFFFCFF): The specified `Id` is not supported by the platform.
* `SUSI_STATUS_BUSY_COLLISION` (0xFFFFFBFD): The I2C bus is busy, or a data collision was detected.
* `SUSI_STATUS_TIMEOUT` (0xFFFFFBFE): A timeout occurred due to clock stretching by the I2C device.
* `SUSI_STATUS_NOT_FOUND` (0xFFFFFBFF): The I2C device did not acknowledge its address.
* `SUSI_STATUS_WRITE_ERROR` (0xFFFFFAFE): An error occurred during the write operation (sending the command/index).

**Example Usage:**

```c
uint8_t readData[4];
//Supporting both standard 7-bit and 10-bit slave addressing modes.
uint32_t result = SusiI2CReadTransfer(SUSI_ID_I2C_EXTERNAL, 0x50, 0x0A, readData, 4); // Read 4 bytes from register 0x0A
if (result == SUSI_STATUS_SUCCESS)
{
    // Data was successfully read from the I2C device.
}
```

### 3.4.4 SusiI2CWriteTransfer

```c
uint32_t SUSI_API SusiI2CWriteTransfer(uint32_t Id, uint32_t Addr, uint32_t Cmd, uint8_t *pBuffer, uint32_t ByteCnt)
```

**Description:** Writes data to a specific register within the selected I2C device.

**Parameters:**

* **`Id`**: Selects the target I2C controller. Refer to the "I2C ID" list .
* **`Addr`**: The encoded 7-bit or 10-bit I2C slave address of the target device.
* **`Cmd`**: The encoded I2C command or register index to write to. Refer to the "I2C Command Encoding" section for encoding details.
* **`pBuffer`**: A pointer to a buffer containing the data to be written to the I2C device.
* **`ByteCnt`**: The size, in bytes, of the data to be written.

**Return Status Code:**

* `SUSI_STATUS_SUCCESS` (0): The write operation completed successfully.
* `SUSI_STATUS_NOT_INITIALIZED` (0xFFFFFFFF): The SUSI API library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (0xFFFFFEFF): An invalid parameter was passed to the function (e.g., `pBuffer` is `NULL` or `ByteCnt` is 0).
* `SUSI_STATUS_INVALID_BLOCK_LENGTH` (0xFFFFFEFD): The specified `ByteCnt` exceeds the maximum block length supported by the I2C controller.
* `SUSI_STATUS_UNSUPPORTED` (0xFFFFFCFF): The specified `Id` is not supported by the platform.
* `SUSI_STATUS_BUSY_COLLISION` (0xFFFFFBFD): The I2C bus is busy, or a data collision was detected.
* `SUSI_STATUS_TIMEOUT` (0xFFFFFBFE): A timeout occurred due to clock stretching by the I2C device.
* `SUSI_STATUS_NOT_FOUND` (0xFFFFFBFF): The I2C device did not acknowledge its address.
* `SUSI_STATUS_WRITE_ERROR` (0xFFFFFAFE): An error occurred during the write operation.

**I2C ID:**

* `SUSI_ID_I2C_EXTERNAL` (Value: `0`): Represents the main I2C host controller on the platform.
* `SUSI_ID_I2C_OEM0` (Value: `1`): Represents an additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM1` (Value: `2`): Represents another additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM2` (Value: `3`): Represents yet another additional I2C host controller (OEM-specific).

**I2C Command Encoding:**

* **Standard Command:** A single byte command.
* **Extended Command:** A word command encoded by ORing the command value with `0x80000000`. For example, the command `0xFABC` would be encoded as `0x8000FABC`.
* **No Command:**  Use `0x4000xxxx` (where `xxxx` can be any value) to indicate that no command is being used. The command parameter will be ignored in this case.


**Example Usage:**

```c
//Supporting both standard 7-bit and 10-bit slave addressing modes.
uint8_t writeData[4] = {0x10, 0x20, 0x30, 0x40};
uint32_t result = SusiI2CWriteTransfer(SUSI_ID_I2C_EXTERNAL, 0x50, 0x0A, writeData, 4); // Write 4 bytes to register 0x0A
if (result == SUSI_STATUS_SUCCESS)
{
    // Data was successfully written to the I2C device.
}
```

### 3.4.5 SusiI2CProbeDevice

```c
uint32_t SUSI_API SusiI2CProbeDevice(uint32_t Id, uint32_t Addr)
```

**Description:** Only Probes the I2C bus for a device at the specified address. This function sends a simple I2C address frame to check if a device responds.

**Parameters:**

* **`Id`**: Selects the target I2C controller. Refer to the "I2C ID" list .
* **`Addr`**: The encoded 7-bit or 10-bit I2C slave address of the device to probe.

**Return Status Code:**

* `SUSI_STATUS_SUCCESS` (0): A device at the specified address responded to the probe.
* `SUSI_STATUS_NOT_INITIALIZED` (0xFFFFFFFF): The SUSI API library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (0xFFFFFCFF): The specified `Id` is not supported by the platform.
* `SUSI_STATUS_BUSY_COLLISION` (0xFFFFFBFD): The I2C bus is busy, or a data collision was detected.
* `SUSI_STATUS_TIMEOUT` (0xFFFFFBFE): A timeout occurred, indicating no device responded.
* `SUSI_STATUS_NOT_FOUND` (0xFFFFFBFF): The I2C device did not acknowledge its address.
* `SUSI_STATUS_WRITE_ERROR` (0xFFFFFAFE): An error occurred during the probe operation.

**I2C ID:**

* `SUSI_ID_I2C_EXTERNAL` (Value: `0`): Represents the main I2C host controller on the platform.
* `SUSI_ID_I2C_OEM0` (Value: `1`): Represents an additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM1` (Value: `2`): Represents another additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM2` (Value: `3`): Represents yet another additional I2C host controller (OEM-specific).


**Example Usage:**

```c
uint32_t result = SusiI2CProbeDevice(SUSI_ID_I2C_EXTERNAL, 0x50);
//Supporting both standard 7-bit and 10-bit slave addressing modes.
if (result == SUSI_STATUS_SUCCESS)
{
    // A device was found at address 0x50.
}
```

### 3.4.6 SusiI2CGetFrequency

```c
uint32_t SUSI_API SusiI2CGetFrequency(uint32_t Id, uint32_t *pFreq)
```

**Description:** Retrieves the current clock frequency of the specified I2C controller.Supporting both standard 7-bit and 10-bit slave addressing modes.

**Parameters:**

* **`Id`**: Selects the target I2C controller. Refer to the "I2C ID" list .
* **`pFreq`**: A pointer to a `uint32_t` variable that will receive the I2C clock frequency in Hertz (Hz).

**Return Status Code:**

* `SUSI_STATUS_SUCCESS` (0): The I2C clock frequency was successfully retrieved.
* `SUSI_STATUS_NOT_INITIALIZED` (0xFFFFFFFF): The SUSI API library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (0xFFFFFCFF): The specified `Id` is not supported by the platform.
* `SUSI_STATUS_INVALID_PARAMETER` (0xFFFFFEFF): An invalid parameter was passed to the function (e.g., `pFreq` is `NULL`).

**I2C ID:**

* `SUSI_ID_I2C_EXTERNAL` (Value: `0`): Represents the main I2C host controller on the platform.
* `SUSI_ID_I2C_OEM0` (Value: `1`): Represents an additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM1` (Value: `2`): Represents another additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM2` (Value: `3`): Represents yet another additional I2C host controller (OEM-specific).


**Example Usage:**

```c
uint32_t frequency;
uint32_t result = SusiI2CGetFrequency(SUSI_ID_I2C_EXTERNAL, &frequency);
if (result == SUSI_STATUS_SUCCESS)
{
    // frequency now contains the I2C clock frequency in Hz.
}
```

### 3.4.7 SusiI2CSetFrequency

```c
uint32_t SUSI_API SusiI2CSetFrequency(uint32_t Id, uint32_t Freq)
```

**Description:**

Sets the I2C clock frequency.Supporting both standard 7-bit and 10-bit slave addressing modes.

**Parameters:**

* `Id`: Selects the target I2C device. See "I2C IDs" above for possible values.
* `Freq`: I2C clock frequency value (in Hz).

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): I2C clock frequency set successfully.

**I2C ID:**

* `SUSI_ID_I2C_EXTERNAL` (Value: `0`): Represents the main I2C host controller on the platform.
* `SUSI_ID_I2C_OEM0` (Value: `1`): Represents an additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM1` (Value: `2`): Represents another additional I2C host controller (OEM-specific).
* `SUSI_ID_I2C_OEM2` (Value: `3`): Represents yet another additional I2C host controller (OEM-specific).


### 3.5.1 SusiSMBReadByte

```c
uint32_t SUSI_API SusiSMBReadByte(uint32_t Id, uint8_t Addr, uint8_t Cmd, uint8_t *pData)
```

**Description:**

Reads a byte of data from the target slave device on the SMBus.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.
* `Cmd`: Specifies the offset or command of the device register to read data from.
* `pData`: Pointer to a variable that receives the read byte data.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.


**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pData` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write operation not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Byte read successfully.

### 3.5.2 SusiSMBWriteByte

```c
uint32_t SUSI_API SusiSMBWriteByte(uint32_t Id, uint8_t Addr, uint8_t Cmd, uint8_t Data)
```

**Description:**

Writes a byte of data to the target slave device on the SMBus.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.
* `Cmd`: Specifies the offset or command of the device register to write data to.
* `Data`: Specifies the byte data to be written.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write operation not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Byte written successfully.

### 3.5.3 SusiSMBReadWord

```c
uint32_t SUSI_API SusiSMBReadWord(uint32_t Id, uint8_t Addr, uint8_t Cmd, uint16_t *pData)
```

**Description:**

Reads a word (2 bytes) of data from the target slave device on the SMBus.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.
* `Cmd`: Specifies the offset or command of the device register to read data from.
* `pData`: Pointer to a variable that receives the read word data.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pData` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write operation not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Word read successfully.

### 3.5.4 SusiSMBWriteWord

```c
uint32_t SUSI_API SusiSMBWriteWord(uint32_t Id, uint8_t Addr, uint8_t Cmd, uint16_t Data)
```

**Description:**

Writes a word (2 bytes) of data to the target slave device on the SMBus.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.
* `Cmd`: Specifies the offset or command of the device register to write data to.
* `Data`: Specifies the word data to be written.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write operation not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Word written successfully.

### 3.5.5 SusiSMBReceiveByte

```c
uint32_t SUSI_API SusiSMBReceiveByte(uint32_t Id, uint8_t Addr, uint8_t *pData)
```

**Description:**

Receives a byte of data from the target slave device on the SMBus.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.
* `pData`: Pointer to a variable that receives the received byte data.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pData` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write operation not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Byte received successfully.

### 3.5.6 SusiSMBSendByte

```c
uint32_t SUSI_API SusiSMBSendByte(uint32_t Id, uint8_t Addr, uint8_t Data)
```

**Description:**

Sends a byte of data to the target slave device on the SMBus.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.
* `Data`: Specifies the byte data to be sent.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write operation not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Byte sent successfully.

### 3.5.7 SusiSMBReadQuick

```c
uint32_t SUSI_API SusiSMBReadQuick(uint32_t Id, uint8_t Addr)
```

**Description:**

Performs a quick read operation on the SMBus, which sends the slave address with the read bit set and checks for an acknowledge.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Quick read operation successful (device acknowledged).

### 3.5.8 SusiSMBWriteQuick

```c
uint32_t SUSI_API SusiSMBWriteQuick(uint32_t Id, uint8_t Addr)
```

**Description:**

Performs a quick write operation on the SMBus, which sends the slave address with the write bit set and checks for an acknowledge.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`. It means giving wrong id.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Quick write operation successful (device acknowledged).



### 3.5.9 SusiSMBReadBlock

```c
uint32_t SUSI_API SusiSMBReadBlock(uint32_t Id, uint8_t Addr, uint8_t Cmd, uint8_t *pBuffer, uint32_t *pLength)
```

**Description:**

Reads a block of data from the target slave device on the SMBus.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.
* `Cmd`: Specifies the offset or command of the device register to read data from.
* `pBuffer`: Pointer to a buffer that receives the read block data.
* `pLength`: Pointer to a variable that specifies the maximum number of bytes to be read. Upon successful completion, this variable contains the actual number of bytes read.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pBuffer` is NULL or `pLength` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write operation not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Block read successfully.

### 3.5.10 SusiSMBWriteBlock

```c
uint32_t SUSI_API SusiSMBWriteBlock(uint32_t Id, uint8_t Addr, uint8_t Cmd, uint8_t *pBuffer, uint32_t Length)
```

**Description:**

Writes a block of data to the target slave device on the SMBus.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.
* `Cmd`: Specifies the offset or command of the device register to write data to.
* `pBuffer`: Pointer to a buffer containing the block data to be written.
* `Length`: Specifies the number of bytes to be written.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pBuffer` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write operation not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Block written successfully.

### 3.5.11 SusiSMBI2CReadBlock

```c
uint32_t SUSI_API SusiSMBI2CReadBlock(uint32_t Id, uint8_t Addr, uint8_t Cmd, uint8_t *pBuffer, uint32_t *pLength)
```

**Description:**

Reads a block of data from the target slave device on the SMBus using the I2C block protocol.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.
* `Cmd`: Specifies the offset or command of the device register to read data from.
* `pBuffer`: Pointer to a buffer that receives the read block data.
* `pLength`: Pointer to a variable that specifies the maximum number of bytes to be read. Upon successful completion, this variable contains the actual number of bytes read.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pBuffer` is NULL or `pLength` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device does not support the I2C block protocol.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write operation not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Block read successfully.

### 3.5.12 SusiSMBI2CWriteBlock

```c
uint32_t SUSI_API SusiSMBI2CWriteBlock(uint32_t Id, uint8_t Addr, uint8_t Cmd, uint8_t *pBuffer, uint32_t Length)
```

**Description:**

Writes a block of data to the target slave device on the SMBus using the I2C block protocol.

**Parameters:**

* `Id`: Selects the target SMBus device. See "SMBus IDs" above for possible values.
* `Addr`: Specifies the 8-bit device address (0x00 to 0xFF). The least significant bit (LSB) of the slave address, which indicates read (1) or write (0), can be ignored.
* `Cmd`: Specifies the offset or command of the device register to write data to.
* `pBuffer`: Pointer to a buffer containing the block data to be written.
* `Length`: Specifies the number of bytes to be written.

**SMBus IDs:**

* `SUSI_ID_SMBUS_EXTERNAL` (Value: `0`): Main SMBus host device.
* `SUSI_ID_SMBUS_OEM0` (Value: `1`) to `SUSI_ID_SMBUS_OEM3` (Value: `4`): Other SMBus host devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pBuffer` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device does not support the I2C block protocol.
* `SUSI_STATUS_BUSY_COLLISION` (Value: `0xFFFFFBFD`): Bus busy (SDA/SCL low) or arbitration/collision error.
* `SUSI_STATUS_TIMEOUT` (Value: `0xFFFFFBFE`): Timeout due to clock stretching.
* `SUSI_STATUS_NOT_FOUND` (Value: `0xFFFFFBFF`): Address not acknowledged.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write operation not acknowledged.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Block written successfully.


### 3.6.1 SusiWDogGetCaps

```c
uint32_t SUSI_API SusiWDogGetCaps(uint32_t Id, uint32_t ItemId, uint32_t *pValue)
```

**Description:**

Retrieves watchdog timer capabilities.

**Parameters:**

* `Id`: Selects the target watchdog timer device. See "Watchdog IDs" above for possible values.
* `ItemId`: Selects the target capability. See "Watchdog Capabilities Item IDs" below for possible values.
* `pValue`: Pointer to a buffer that receives the target capability value.

**Watchdog IDs:**

* `SUSI_ID_WATCHDOG_1` (Value: `0`): First watchdog timer.
* `SUSI_ID_WATCHDOG_2` (Value: `1`): Second watchdog timer.
* `SUSI_ID_WATCHDOG_3` (Value: `2`): Third watchdog timer.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pValue` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or `ItemId`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Capability retrieved successfully.

**Watchdog Capabilities Item IDs:**

* `SUSI_ID_WDT_SUPPORT_FLAGS` (Value: `0x00000000`): Event support flags. See "Watchdog Support Flags" above for details.
* `SUSI_ID_WDT_DELAY_MAXIMUM` (Value: `0x00000001`): The maximum delay time value.
* `SUSI_ID_WDT_DELAY_MINIMUM` (Value: `0x00000002`): The minimum delay time value.
* `SUSI_ID_WDT_EVENT_MAXIMUM` (Value: `0x00000003`): The maximum event time value.
* `SUSI_ID_WDT_EVENT_MINIMUM` (Value: `0x00000004`): The minimum event time value.
* `SUSI_ID_WDT_RESET_MAXIMUM` (Value: `0x00000005`): The maximum reset time value.
* `SUSI_ID_WDT_RESET_MINIMUM` (Value: `0x00000006`): The minimum reset time value.
* `SUSI_ID_WDT_UNIT_MINIMUM` (Value: `0x0000000F`): The minimum unit value.
* `SUSI_ID_WDT_DELAY_TIME` (Value: `0x00010001`): Current delay time setting.
* `SUSI_ID_WDT_EVENT_TIME` (Value: `0x00010002`): Current event time setting.
* `SUSI_ID_WDT_RESET_TIME` (Value: `0x00010003`): Current reset time setting.
* `SUSI_ID_WDT_EVENT_TYPE` (Value: `0x00010004`): Current event type. See "Watchdog Timer Event Types" above for details.
* `SUSI_ID_WDT_EVENT_STATUS` (Value: `0x00010005`): Current status of the watchdog timer (0: stopped, 1: running).


**Watchdog Support Flags:**

* `SUSI_WDT_FLAG_SUPPORT_IRQ` (Value: `0x02`): Supports IRQ event.
* `SUSI_WDT_FLAG_SUPPORT_SCI` (Value: `0x04`): Supports SCI event.
* `SUSI_WDT_FLAG_SUPPORT_PWRCYCLE` (Value: `0x08`): Supports power cycle event.
* `SUSI_WDT_FLAG_SUPPORT_PIN` (Value: `0x10`): Supports pin event.


### 3.6.2 SusiWDogStart 
**Description:** 

Starts the watchdog timer and sets its parameters. To adjust the parameters, the watchdog timer must be stopped and then started again with the new values. If the hardware implementation of the watchdog timer does not allow setting the exact time selected, the SUSI API selects the next possible longer timing.

**Parameters:**

* `Id`: Selects the target watchdog timer device. See "Watchdog IDs" below for possible values.
* `DelayTime`: Initial delay for the watchdog timer in milliseconds.
* `EventTime`: Watchdog timeout interval in milliseconds to trigger an event.
* `ResetTime`: Watchdog timeout interval in milliseconds to trigger a reset.
* `EventType`: Selects the type of event to trigger. See "Watchdog Timer Event Types" below for possible values.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): Time values are outside the allowed range.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Watchdog timer started successfully.

**Watchdog IDs:**

* `SUSI_ID_WATCHDOG_1` (Value: `0`): First watchdog timer.
* `SUSI_ID_WATCHDOG_2` (Value: `1`): Second watchdog timer.
* `SUSI_ID_WATCHDOG_3` (Value: `2`): Third watchdog timer.

**Watchdog Timer Event Types:** (someone called Watchdog Event Types )

* `SUSI_WDT_EVENT_TYPE_NONE`: No event.
* `SUSI_WDT_EVENT_TYPE_SCI`: SCI event.
* `SUSI_WDT_EVENT_TYPE_IRQ`: IRQ event.
* `SUSI_WDT_EVENT_TYPE_PWRCYCLE`: Power cycle event.
* `SUSI_WDT_EVENT_TYPE_PIN`: Pin event.

### 3.6.3 SusiWDogStop

```c
uint32_t SUSI_API SusiWDogStop(uint32_t Id)
```

**Description:**

Stops the operation of the watchdog timer.

**Parameters:**

* `Id`: Selects the target watchdog timer device. See "Watchdog IDs" above for possible values.

**Watchdog IDs:**

* `SUSI_ID_WATCHDOG_1` (Value: `0`): First watchdog timer.
* `SUSI_ID_WATCHDOG_2` (Value: `1`): Second watchdog timer.
* `SUSI_ID_WATCHDOG_3` (Value: `2`): Third watchdog timer.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Watchdog timer stopped successfully.

### 3.6.4 SusiWDogTrigger

```c
uint32_t SUSI_API SusiWDogTrigger(uint32_t Id)
```

**Description:**

Triggers (or "pets") the watchdog timer, resetting its internal counter and preventing a timeout.

**Parameters:**

* `Id`: Selects the target watchdog timer device. See "Watchdog IDs" above for possible values.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Watchdog timer triggered successfully.

**Watchdog IDs:**

* `SUSI_ID_WATCHDOG_1` (Value: `0`): First watchdog timer.
* `SUSI_ID_WATCHDOG_2` (Value: `1`): Second watchdog timer.
* `SUSI_ID_WATCHDOG_3` (Value: `2`): Third watchdog timer.

#### 3.6.5 SusiWDogSetCallBack

```c
uint32_t SUSI_API SusiWDogSetCallBack(uint32_t Id, SUSI_WDT_INT_CALLBACK pfnCallback, void *Context)
```

**Description:**

Sets a callback function to be called when an IRQ event is triggered by the watchdog timer.

**Parameters:**

* `Id`: Selects the target watchdog timer device. See "Watchdog IDs" above for possible values.
* `pfnCallback`: Pointer to the callback function. Set to NULL to clear the callback. The callback function should have the following signature: `void (*SUSI_WDT_INT_CALLBACK)(void*)`.
* `Context`: Pointer to a user-defined context structure that will be passed to the callback function.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Callback function set successfully.

**Watchdog IDs:**

* `SUSI_ID_WATCHDOG_1` (Value: `0`): First watchdog timer.
* `SUSI_ID_WATCHDOG_2` (Value: `1`): Second watchdog timer.
* `SUSI_ID_WATCHDOG_3` (Value: `2`): Third watchdog timer.


### 3.7.1 SusiGPIOGetCaps

```c
uint32_t SUSI_API SusiGPIOGetCaps(uint32_t Id, uint32_t ItemId, uint32_t *pValue)
```

**Description:**

Retrieves the capabilities of the selected GPIO interface.

**Parameters:**

* `Id`: Selects the target GPIO device or bank. See "GPIO IDs" above for possible values.
* `ItemId`: Selects the target capability. See "GPIO Capabilities Item IDs" below for possible values.
* `pValue`: Pointer to a buffer that receives the target capability value. Each bit in the buffer represents the support status of a GPIO pin, according to its order. A value of 1 indicates support, and 0 indicates no support.


**GPIO IDs:**

* `SUSI_ID_GPIO(GPIO_NUM)`: Represents a specific GPIO pin, where `GPIO_NUM` is the pin number.
* `SUSI_ID_GPIO_BANK(BANK_NUM)`: Represents a bank of GPIO pins, where `BANK_NUM` is the bank number. This ID is calculated as `0x00010000 + BANK_NUM`.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pValue` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Capabilities retrieved successfully.

**GPIO Capabilities Item IDs:**

* `SUSI_ID_GPIO_INPUT_SUPPORT` (Value: `0x00000000`): Retrieves the GPIO input support status.
* `SUSI_ID_GPIO_OUTPUT_SUPPORT` (Value: `0x00000001`): Retrieves the GPIO output support status.

### 3.7.2 SusiGPIOGetDirection

```c
uint32_t SUSI_API SusiGPIOGetDirection(uint32_t Id, uint32_t Bitmask, uint32_t *pDirection)
```

**Description:**

Retrieves the direction (input or output) of the selected GPIO pins.

**Parameters:**

* `Id`: Selects the target GPIO device or bank. See "GPIO IDs" above for possible values.
* `Bitmask`: Value for a bit mask. Only selected bits are retrieved. Unselected bits remain unchanged. This parameter is ignored when using single-pin mode (`SUSI_ID_GPIO(GPIO_NUM)`).
* `pDirection`: Pointer to a buffer that receives the direction of the selected GPIO pins. A value of 0 indicates output, and 1 indicates input.


**GPIO IDs:**

* `SUSI_ID_GPIO(GPIO_NUM)`: Represents a specific GPIO pin, where `GPIO_NUM` is the pin number.
* `SUSI_ID_GPIO_BANK(BANK_NUM)`: Represents a bank of GPIO pins, where `BANK_NUM` is the bank number. This ID is calculated as `0x00010000 + BANK_NUM`.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pDirection` is NULL, or `Bitmask` is 0 when using bank mode (`SUSI_ID_GPIO_BANK(BANK_NUM)`).
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Direction retrieved successfully.

### 3.7.3 SusiGPIOSetDirection

```c
uint32_t SUSI_API SusiGPIOSetDirection(uint32_t Id, uint32_t Bitmask, uint32_t Direction)
```

**Description:**

Sets the direction (input or output) of the selected GPIO pins.

**Parameters:**

* `Id`: Selects the target GPIO device or bank. See "GPIO IDs" above for possible values.
* `Bitmask`: Value for a bit mask. Only selected bits are changed. Unselected bits remain unchanged. This parameter is ignored when using single-pin mode (`SUSI_ID_GPIO(GPIO_NUM)`).
* `Direction`: Sets the direction of the selected GPIO pins. A value of 0 indicates output, and 1 indicates input.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `Bitmask` is 0 when using bank mode (`SUSI_ID_GPIO_BANK(BANK_NUM)`).
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Direction set successfully.


**GPIO IDs:**

* `SUSI_ID_GPIO(GPIO_NUM)`: Represents a specific GPIO pin, where `GPIO_NUM` is the pin number.
* `SUSI_ID_GPIO_BANK(BANK_NUM)`: Represents a bank of GPIO pins, where `BANK_NUM` is the bank number. This ID is calculated as `0x00010000 + BANK_NUM`.


### 3.7.4 SusiGPIOGetLevel

```c
uint32_t SUSI_API SusiGPIOGetLevel(uint32_t Id, uint32_t Bitmask, uint32_t *pLevel)
```

**Description:**

Reads the logic level (high:1 or low:0) of the selected GPIO pins.

**Parameters:**

* `Id`: Selects the target GPIO device or bank. See "GPIO IDs" above for possible values.
* `Bitmask`: Value for a bit mask. Only selected bits are read. Unselected bits remain unchanged. This parameter is ignored when using single-pin mode (`SUSI_ID_GPIO(GPIO_NUM)`).
* `pLevel`: Pointer to a buffer that receives the logic level of the selected GPIO pins.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pLevel` is NULL, or `Bitmask` is 0 when using bank mode (`SUSI_ID_GPIO_BANK(BANK_NUM)`).
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Logic level read successfully.


**GPIO IDs:**

* `SUSI_ID_GPIO(GPIO_NUM)`: Represents a specific GPIO pin, where `GPIO_NUM` is the pin number.
* `SUSI_ID_GPIO_BANK(BANK_NUM)`: Represents a bank of GPIO pins, where `BANK_NUM` is the bank number. This ID is calculated as `0x00010000 + BANK_NUM`.


### 3.7.5 SusiGPIOSetLevel

```c
uint32_t SUSI_API SusiGPIOSetLevel(uint32_t Id, uint32_t Bitmask, uint32_t Level)
```

**Description:**

Sets the logic level (high:1 or low:0) of the selected GPIO pins. Depending on the hardware implementation, writing to multiple GPIO pins using the bit mask option may not guarantee a time-synchronous change of the output levels.

**Parameters:**

* `Id`: Selects the target GPIO device or bank. See "GPIO IDs" above for possible values.
* `Bitmask`: Value for a bit mask. Only selected bits are changed. Unselected bits remain unchanged. This parameter is ignored when using single-pin mode (`SUSI_ID_GPIO(GPIO_NUM)`).
* `Level`: Sets the logic level of the selected GPIO pins.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `Bitmask` is 0 when using bank mode (`SUSI_ID_GPIO_BANK(BANK_NUM)`).
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Logic level set successfully.

**GPIO IDs:**

* `SUSI_ID_GPIO(GPIO_NUM)`: Represents a specific GPIO pin, where `GPIO_NUM` is the pin number.
* `SUSI_ID_GPIO_BANK(BANK_NUM)`: Represents a bank of GPIO pins, where `BANK_NUM` is the bank number. This ID is calculated as `0x00010000 + BANK_NUM`.

### 3.8 Smart Fan Functions

The Smart Fan functions allow you to configure and control the fan speed based on temperature readings.

**Smart Fan Configuration Structure:**

```c
#define SUSI_FAN_AUTO_CTRL_OPMODE_PWM 0
#define SUSI_FAN_AUTO_CTRL_OPMODE_RPM 1

typedef struct _AutoFan {
    uint32_t TmlSource;        // Thermal source ID (See "Hardware Monitor (HWM) Value IDs" below)
    uint32_t OpMode;           // Operation mode (SUSI_FAN_AUTO_CTRL_OPMODE_PWM or SUSI_FAN_AUTO_CTRL_OPMODE_RPM)
    uint32_t LowStopLimit;     // Temperature (0.1 Kelvins) below which the fan stops
    uint32_t LowLimit;         // Temperature (0.1 Kelvins) at which the fan starts running at minimum speed
    uint32_t HighLimit;        // Temperature (0.1 Kelvins) at which the fan runs at maximum speed
    uint32_t MinPWM;           // Minimum PWM duty cycle (0-100%) when OpMode is SUSI_FAN_AUTO_CTRL_OPMODE_PWM
    uint32_t MaxPWM;           // Maximum PWM duty cycle (0-100%) when OpMode is SUSI_FAN_AUTO_CTRL_OPMODE_PWM
    uint32_t MinRPM;           // Minimum fan speed (RPM) when OpMode is SUSI_FAN_AUTO_CTRL_OPMODE_RPM
    uint32_t MaxRPM;           // Maximum fan speed (RPM) when OpMode is SUSI_FAN_AUTO_CTRL_OPMODE_RPM
} AutoFan, *PAutoFan;

#define SUSI_FAN_CTRL_MODE_OFF 0
#define SUSI_FAN_CTRL_MODE_FULL 1
#define SUSI_FAN_CTRL_MODE_MANUAL 2
#define SUSI_FAN_CTRL_MODE_AUTO 3

typedef struct _SusiFanControl {
    uint32_t Mode;              // Fan control mode (See "Fan Control Modes" below)
    uint32_t PWM;               // Manual PWM duty cycle (0-100%) when Mode is SUSI_FAN_CTRL_MODE_MANUAL
    AutoFan AutoControl;       // Auto mode configuration when Mode is SUSI_FAN_CTRL_MODE_AUTO
} SusiFanControl, *PSusiFanControl;
```

**Fan Control Modes:**

* `SUSI_FAN_CTRL_MODE_OFF`: Fan is off.
* `SUSI_FAN_CTRL_MODE_FULL`: Fan runs at full speed.
* `SUSI_FAN_CTRL_MODE_MANUAL`: Fan speed is controlled manually using the `PWM` member.
* `SUSI_FAN_CTRL_MODE_AUTO`: Fan speed is controlled automatically based on the `AutoControl` configuration.

**Fan Control Support Flags:**

* `SUSI_FC_FLAG_SUPPORT_OFF_MODE` (Value: `0x01`): Supports off mode.
* `SUSI_FC_FLAG_SUPPORT_FULL_MODE` (Value: `0x02`): Supports full mode.
* `SUSI_FC_FLAG_SUPPORT_MANUAL_MODE` (Value: `0x04`): Supports manual mode.
* `SUSI_FC_FLAG_SUPPORT_AUTO_MODE` (Value: `0x08`): Supports auto mode.

**Fan Auto Support Flags:**

* `SUSI_FC_FLAG_SUPPORT_AUTO_LOW_STOP` (Value: `0x01`): Auto mode supports low stop limit.
* `SUSI_FC_FLAG_SUPPORT_AUTO_LOW_LIMIT` (Value: `0x02`): Auto mode supports low limit.
* `SUSI_FC_FLAG_SUPPORT_AUTO_HIGH_LIMIT` (Value: `0x04`): Auto mode supports high limit.
* `SUSI_FC_FLAG_SUPPORT_AUTO_PWM` (Value: `0x0100`): Auto mode supports PWM operation.
* `SUSI_FC_FLAG_SUPPORT_AUTO_RPM` (Value: `0x0200`): Auto mode supports RPM operation.

### 3.8.1 SusiFanControlGetCaps in c code

```c
uint32_t SUSI_API SusiFanControlGetCaps(uint32_t Id, uint32_t ItemId, uint32_t *pValue)
```

**Description:**

Retrieves fan control capabilities. Use SusiBoardGetValue to get fan speed. SusiFanControlGetCaps is only for capabilities.

**Parameters:**

* `Id`: Smart fan ID, which is the same as the Fan Speed Value ID. See "Hardware Monitor (HWM) Value IDs" above for possible values.
* `ItemId`: Selects the target capability. See "Fan Control Capabilities Item IDs" above for possible values. You can also use a temperature ID (see "Hardware Monitor (HWM) Value IDs" above) to check if it is supported in the `SusiFanControl` function.
* `pValue`: Pointer to a buffer that receives the target capability value.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pValue` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or `ItemId`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Capability retrieved successfully.

**Hardware Monitor Value IDs (for Thermal Source):**

* `SUSI_ID_HWM_TEMP_CPU` (Value: `0x00020000`): CPU temperature.
* `SUSI_ID_HWM_TEMP_CHIPSET` (Value: `0x00020001`): Chipset temperature.
* `SUSI_ID_HWM_TEMP_SYSTEM` (Value: `0x00020002`): System temperature.
* `SUSI_ID_HWM_TEMP_CPU2` (Value: `0x00020003`): Second CPU temperature (if applicable).
* `SUSI_ID_HWM_TEMP_OEM0` (Value: `0x00020004`) to `SUSI_ID_HWM_TEMP_OEM5` (Value: `0x00020009`): Other temperature sensors.

**Fan Control Capabilities Item IDs:**

* `SUSI_ID_FC_CONTROL_SUPPORT_FLAGS` (Value: `0x00000000`): Control support flags. See "Fan Control Support Flags" below for details.
* `SUSI_ID_FC_AUTO_SUPPORT_FLAGS` (Value: `0x00000001`): Auto support flags. See "Fan Auto Support Flags" below for details.



### 3.8.2 SusiFanControlGetConfig

```c
uint32_t SUSI_API SusiFanControlGetConfig(uint32_t Id, SusiFanControl *pConfig)
```

**Description:**

Retrieves the current fan control mode and configuration/setting.Not fan speed. Not including current fan speed in RPM.

**Parameters:**

* `Id`: Smart fan ID, which is the same as the Fan Speed Value ID. See "Hardware Monitor (HWM) Value IDs" above for possible values.
* `pConfig`: Pointer to a `SusiFanControl` structure that receives the current fan control configuration.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pConfig` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device does not support smart fan control.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Fan control configuration retrieved successfully.

**Hardware Monitor (HWM) Value IDs (for Thermal Source):**

* `SUSI_ID_HWM_TEMP_CPU` (Value: `0x00020000`): CPU temperature.
* `SUSI_ID_HWM_TEMP_CHIPSET` (Value: `0x00020001`): Chipset temperature.
* `SUSI_ID_HWM_TEMP_SYSTEM` (Value: `0x00020002`): System temperature.
* `SUSI_ID_HWM_TEMP_CPU2` (Value: `0x00020003`): Second CPU temperature (if applicable).
* `SUSI_ID_HWM_TEMP_OEM0` (Value: `0x00020004`) to `SUSI_ID_HWM_TEMP_OEM5` (Value: `0x00020009`): Other temperature sensors.

```c
#define SUSI_FAN_CTRL_MODE_OFF 0
#define SUSI_FAN_CTRL_MODE_FULL 1
#define SUSI_FAN_CTRL_MODE_MANUAL 2
#define SUSI_FAN_CTRL_MODE_AUTO 3

typedef struct _SusiFanControl {
    uint32_t Mode;              // Fan control mode (See "Fan Control Modes" below)
    uint32_t PWM;               // Manual PWM duty cycle (0-100%) when Mode is SUSI_FAN_CTRL_MODE_MANUAL
    AutoFan AutoControl;       // Auto mode configuration when Mode is SUSI_FAN_CTRL_MODE_AUTO
} SusiFanControl, *PSusiFanControl;
```

**Fan Control Modes:**

* `SUSI_FAN_CTRL_MODE_OFF`: Fan is off.
* `SUSI_FAN_CTRL_MODE_FULL`: Fan runs at full speed.
* `SUSI_FAN_CTRL_MODE_MANUAL`: Fan speed is controlled manually using the `PWM` member.
* `SUSI_FAN_CTRL_MODE_AUTO`: Fan speed is controlled automatically based on the `AutoControl` configuration.


### 3.8.3 SusiFanControlSetConfig

```c
uint32_t SUSI_API SusiFanControlSetConfig(uint32_t Id, SusiFanControl *pConfig)
```

**Description:**

Sets the fan control mode and configuration/setting.Not fan speed. Not including current fan speed in RPM.

**Parameters:**

* `Id`: Smart fan ID, which is the same as the Fan Speed Value ID. See "Hardware Monitor (HWM) Value IDs" above for possible values.
* `pConfig`: Pointer to a `SusiFanControl` structure containing the desired fan control configuration.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pConfig` is NULL or contains invalid configuration values.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Fan control configuration set successfully.

**Hardware Monitor (HWM) Value IDs (for Thermal Source):**

* `SUSI_ID_HWM_TEMP_CPU` (Value: `0x00020000`): CPU temperature.
* `SUSI_ID_HWM_TEMP_CHIPSET` (Value: `0x00020001`): Chipset temperature.
* `SUSI_ID_HWM_TEMP_SYSTEM` (Value: `0x00020002`): System temperature.
* `SUSI_ID_HWM_TEMP_CPU2` (Value: `0x00020003`): Second CPU temperature (if applicable).
* `SUSI_ID_HWM_TEMP_OEM0` (Value: `0x00020004`) to `SUSI_ID_HWM_TEMP_OEM5` (Value: `0x00020009`): Other temperature sensors.

```c
#define SUSI_FAN_CTRL_MODE_OFF 0
#define SUSI_FAN_CTRL_MODE_FULL 1
#define SUSI_FAN_CTRL_MODE_MANUAL 2
#define SUSI_FAN_CTRL_MODE_AUTO 3

typedef struct _SusiFanControl {
    uint32_t Mode;              // Fan control mode (See "Fan Control Modes" below)
    uint32_t PWM;               // Manual PWM duty cycle (0-100%) when Mode is SUSI_FAN_CTRL_MODE_MANUAL
    AutoFan AutoControl;       // Auto mode configuration when Mode is SUSI_FAN_CTRL_MODE_AUTO
} SusiFanControl, *PSusiFanControl;
```
**Fan Control Modes:**

* `SUSI_FAN_CTRL_MODE_OFF`: Fan is off.
* `SUSI_FAN_CTRL_MODE_FULL`: Fan runs at full speed.
* `SUSI_FAN_CTRL_MODE_MANUAL`: Fan speed is controlled manually using the `PWM` member.
* `SUSI_FAN_CTRL_MODE_AUTO`: Fan speed is controlled automatically based on the `AutoControl` configuration.

### 3.8.4 
To set the smart fan to auto mode. Here are the steps:

```c
//step1. **Create a `SusiFanControl` structure:** Create a `SusiFanControl` structure variable and set its member variables.

SusiFanControl fanConfig;
fanConfig.Mode = SUSI_FAN_CTRL_MODE_AUTO; // Set to auto mode

//step2. **Configure auto mode parameters:** Configure the `AutoControl` member variable of the `fanConfig` structure to define the auto mode parameters, such as the thermal source, temperature thresholds, fan speed, etc.

fanConfig.AutoControl.TmlSource = SUSI_ID_HWM_TEMP_CPU; // Use CPU temperature as the control source
fanConfig.AutoControl.LowStopLimit = 3230; // Stop the fan when the temperature is below 50Â°C
fanConfig.AutoControl.LowLimit = 3330; // Start the fan at the minimum speed when the temperature reaches 60Â°C
fanConfig.AutoControl.HighLimit = 3530; // Run the fan at the maximum speed when the temperature reaches 80Â°C
fanConfig.AutoControl.MinPWM = 20; // Minimum PWM duty cycle is 20%
fanConfig.AutoControl.MaxPWM = 100; // Maximum PWM duty cycle is 100%

//step3. **Call the `SusiFanControlSetConfig` function:** Call the `SusiFanControlSetConfig` function with the configured `fanConfig` structure to set the smart fan to auto mode.
SusiFanControlSetConfig(SUSI_ID_HWM_FAN_CPU, &fanConfig);

```

### 3.9 Storage Functions

The Storage functions allow you to access non-volatile storage areas for storing and retrieving user data.


### 3.9.1 SusiStorageGetCaps

```c
uint32_t SUSI_API SusiStorageGetCaps(uint32_t Id, uint32_t ItemId, uint32_t *pValue)
```

**Description:**

Retrieves storage capabilities.

**Parameters:**

* `Id`: Selects the target storage device. See "Storage IDs" above for possible values.
* `ItemId`: Selects the target capability. See "Storage Capabilities Item IDs" below for possible values.
* `pValue`: Pointer to a buffer that receives the target capability value.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pValue` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device is not supported.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Capability retrieved successfully.

**Storage IDs:**

* `SUSI_ID_STORAGE_STD` (Value: `0x00000000`): Standard storage device.
* `SUSI_ID_STORAGE_OEM0` (Value: `0x00000001`) to `SUSI_ID_STORAGE_OEM1` (Value: `0x00000002`): Other storage devices.

**Storage Capabilities Item IDs:**

* `SUSI_ID_STORAGE_TOTAL_SIZE` (Value: `0x00000000`): Total storage size in bytes.
* `SUSI_ID_STORAGE_BLOCK_SIZE` (Value: `0x00000001`): Storage block size in bytes.
* `SUSI_ID_STORAGE_LOCK_STATUS` (Value: `0x00010000`): Storage lock status. See "Storage Lock Status" above for possible values.
* `SUSI_ID_STORAGE_PSW_MAX_LEN` (Value: `0x00010000`): Maximum length of the storage lock password in bytes.

**Storage Lock Status:**

* `SUSI_STORAGE_STATUS_LOCK`: Storage is locked.
* `SUSI_STORAGE_STATUS_UNLOCK`: Storage is unlocked.


### 3.9.2 SusiStorageAreaRead

```c
uint32_t SUSI_API SusiStorageAreaRead(uint32_t Id, uint32_t Offset, uint8_t *pBuffer, uint32_t BufLen)
```

**Description:**

Reads data from the selected user data area in the storage device.

**Parameters:**

* `Id`: Selects the target storage device. See "Storage IDs" above for possible values.
* `Offset`: Storage area start address offset in bytes.
* `pBuffer`: Pointer to a buffer that receives the read data.
* `BufLen`: Size in bytes of the buffer pointed to by `pBuffer`.

**Storage IDs:**

* `SUSI_ID_STORAGE_STD` (Value: `0x00000000`): Standard storage device.
* `SUSI_ID_STORAGE_OEM0` (Value: `0x00000001`) to `SUSI_ID_STORAGE_OEM1` (Value: `0x00000002`): Other storage devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pBuffer` is NULL or `BufLen` is 0.
* `SUSI_STATUS_INVALID_BLOCK_LENGTH` (Value: `0xFFFFFEFD`): `Offset + BufLen` exceeds the total storage size.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_READ_ERROR` (Value: `0xFFFFFAFF`): Read error occurred.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Data read successfully.

### 3.9.3 SusiStorageAreaWrite

```c
uint32_t SUSI_API SusiStorageAreaWrite(uint32_t Id, uint32_t Offset, uint8_t *pBuffer, uint32_t BufLen)
```

**Description:**

Writes data to the selected user data area in the storage device.

**Parameters:**

* `Id`: Selects the target storage device. See "Storage IDs" above for possible values.
* `Offset`: Storage area start address offset in bytes.
* `pBuffer`: Pointer to a buffer containing the data to be written.
* `BufLen`: Size in bytes of the buffer pointed to by `pBuffer`.

**Storage IDs:**

* `SUSI_ID_STORAGE_STD` (Value: `0x00000000`): Standard storage device.
* `SUSI_ID_STORAGE_OEM0` (Value: `0x00000001`) to `SUSI_ID_STORAGE_OEM1` (Value: `0x00000002`): Other storage devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pBuffer` is NULL or `BufLen` is 0.
* `SUSI_STATUS_INVALID_BLOCK_LENGTH` (Value: `0xFFFFFEFD`): `Offset + BufLen` exceeds the total storage size.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id`.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Write error occurred.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Data written successfully.

### 3.9.4 SusiStorageAreaSetLock

```c
uint32_t SUSI_API SusiStorageAreaSetLock(uint32_t Id, uint8_t *pBuffer, uint32_t BufLen)
```

**Description:**

Locks a storage area for write protection.

**Parameters:**

* `Id`: Selects the target storage device. See "Storage IDs" above for possible values.
* `pBuffer`: Pointer to a buffer containing the lock key.
* `BufLen`: Size in bytes of the lock key buffer.

**Storage IDs:**

* `SUSI_ID_STORAGE_STD` (Value: `0x00000000`): Standard storage device.
* `SUSI_ID_STORAGE_OEM0` (Value: `0x00000001`) to `SUSI_ID_STORAGE_OEM1` (Value: `0x00000002`): Other storage devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pBuffer` is NULL or `BufLen` is 0.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Lock error occurred.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device does not support locking.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Storage area locked successfully.

### 3.9.5 SusiStorageAreaSetUnlock

```c
uint32_t SUSI_API SusiStorageAreaSetUnlock(uint32_t Id, uint8_t *pBuffer, uint32_t BufLen)
```

**Description:**

Unlocks a storage area for write protection.

**Parameters:**

* `Id`: Selects the target storage device. See "Storage IDs" above for possible values.
* `pBuffer`: Pointer to a buffer containing the unlock key.
* `BufLen`: Size in bytes of the unlock key buffer.

**Storage IDs:**

* `SUSI_ID_STORAGE_STD` (Value: `0x00000000`): Standard storage device.
* `SUSI_ID_STORAGE_OEM0` (Value: `0x00000001`) to `SUSI_ID_STORAGE_OEM1` (Value: `0x00000002`): Other storage devices.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pBuffer` is NULL or `BufLen` is 0.
* `SUSI_STATUS_WRITE_ERROR` (Value: `0xFFFFFAFE`): Unlock error occurred.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or the device does not support unlocking.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Storage area unlocked successfully.


### 3.10 Thermal Protection Functions

The Thermal Protection functions allow you to configure and control hardware-based thermal monitoring and event notification.


### 3.10.1 SusiThermalProtectionGetCaps

```c
uint32_t SUSI_API SusiThermalProtectionGetCaps(uint32_t Id, uint32_t ItemId, uint32_t *pValue)
```

**Description:**

Retrieves thermal protection capabilities.

**Parameters:**

* `Id`: Selects the target thermal protection zone. See "Thermal Protection IDs" above for possible values.
* `ItemId`: Selects the target capability. See "Thermal Protection Capabilities Item IDs" above for possible values. You can also use a temperature ID (see "Hardware Monitor (HWM) Value IDs" above) to check if it is supported in the `SusiThermalProtection` function.
* `pValue`: Pointer to a buffer that receives the target capability value.

**Return Status Code:**

* `SUSI_STATUS_NOT_INITIALIZED` (Value: `0xFFFFFFFF`): Library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (Value: `0xFFFFFEFF`): `pValue` is NULL.
* `SUSI_STATUS_UNSUPPORTED` (Value: `0xFFFFFCFF`): Unknown `Id` or `ItemId`.
* `SUSI_STATUS_SUCCESS` (Value: `0`): Capability retrieved successfully.

**Thermal Protection IDs:**

* `SUSI_ID_THERMAL_PROTECT_1` (Value: `0`): Thermal protection zone 1.
* `SUSI_ID_THERMAL_PROTECT_2` (Value: `1`): Thermal protection zone 2.
* `SUSI_ID_THERMAL_PROTECT_3` (Value: `2`): Thermal protection zone 3.
* `SUSI_ID_THERMAL_PROTECT_4` (Value: `3`): Thermal protection zone 4.

**Thermal Protection Capabilities Item IDs:**

* `SUSI_ID_TP_EVENT_SUPPORT_FLAGS` (Value: `0x00000000`): Event support flags. See "Thermal Protection Support Flags" below for details.
* `SUSI_ID_TP_EVENT_TRIGGER_MAXIMUM` (Value: `0x00000001`): The maximum temperature to trigger an event.
* `SUSI_ID_TP_EVENT_TRIGGER_MINIMUM` (Value: `0x00000002`): The minimum temperature to trigger an event.
* `SUSI_ID_TP_EVENT_CLEAR_MAXIMUM` (Value: `0x00000003`): The maximum temperature to clear an event.
* `SUSI_ID_TP_EVENT_CLEAR_MINIMUM` (Value: `0x00000004`): The minimum temperature to clear an event.

**Thermal Protection Support Flags:**

* `SUSI_THERMAL_FLAG_SUPPORT_SHUTDOWN` (Value: `0x01`): Supports shutdown event.
* `SUSI_THERMAL_FLAG_SUPPORT_THROTTLE` (Value: `0x02`): Supports throttle event.
* `SUSI_THERMAL_FLAG_SUPPORT_POWEROFF` (Value: `0x04`): Supports power off event.

**Hardware Monitor (HWM) Value IDs (for Thermal Source):**

* `SUSI_ID_HWM_TEMP_CPU` (Value: `0x00020000`): CPU temperature.
* `SUSI_ID_HWM_TEMP_CHIPSET` (Value: `0x00020001`): Chipset temperature.
* `SUSI_ID_HWM_TEMP_SYSTEM` (Value: `0x00020002`): System temperature.
* `SUSI_ID_HWM_TEMP_CPU2` (Value: `0x00020003`): Second CPU temperature (if applicable).
* `SUSI_ID_HWM_TEMP_OEM0` (Value: `0x00020004`) to `SUSI_ID_HWM_TEMP_OEM5` (Value: `0x00020009`): Other temperature sensors.


### 3.10.2 SusiThermalProtectionSetConfig

```c
uint32_t SUSI_API SusiThermalProtectionSetConfig(uint32_t Id, SusiThermalProtect *pConfig)
```

**Description:** This function configures the thermal protection settings for the specified zone using the parameters provided in the `SusiThermalProtect` structure.

**Parameters:**

* **`Id`**: Selects the target thermal protection zone to configure. Refer to the "Thermal Protection IDs" list in section 3.10 for possible values.
* **`pConfig`**: A pointer to a `SusiThermalProtect` structure containing the desired configuration settings.  The members of this structure (described in detail at the beginning of section 3.10) define the temperature source to monitor, the event type to generate, and the temperature thresholds for triggering and clearing the event.

**Return Status Code:**

* `SUSI_STATUS_SUCCESS` (0): The thermal protection configuration was successfully applied.
* `SUSI_STATUS_NOT_INITIALIZED` (0xFFFFFFFF): The SUSI API library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (0xFFFFFEFF): An invalid parameter was passed to the function (e.g., `pConfig` is `NULL` or contains invalid values).
* `SUSI_STATUS_UNSUPPORTED` (0xFFFFFCFF): The specified `Id`, the `SourceId` in the `pConfig` structure, or the `EventType` in the `pConfig` structure is not supported by the platform.

**Thermal Protection IDs:**

* `SUSI_ID_THERMAL_PROTECT_1` (Value: `0`): Thermal protection zone 1.
* `SUSI_ID_THERMAL_PROTECT_2` (Value: `1`): Thermal protection zone 2.
* `SUSI_ID_THERMAL_PROTECT_3` (Value: `2`): Thermal protection zone 3.
* `SUSI_ID_THERMAL_PROTECT_4` (Value: `3`): Thermal protection zone 4.

**Thermal Protection Event Types:**

* `SUSI_THERMAL_EVENT_SHUTDOWN` (Value: `0x00`): Shutdown event.
* `SUSI_THERMAL_EVENT_THROTTLE` (Value: `0x01`): Throttle event.
* `SUSI_THERMAL_EVENT_POWEROFF` (Value: `0x02`): Power off event.
* `SUSI_THERMAL_EVENT_NONE` (Value: `0xFF`): No event.

**Hardware Monitor (HWM) Value IDs (for Thermal Source):**

* `SUSI_ID_HWM_TEMP_CPU` (Value: `0x00020000`): CPU temperature.
* `SUSI_ID_HWM_TEMP_CHIPSET` (Value: `0x00020001`): Chipset temperature.
* `SUSI_ID_HWM_TEMP_SYSTEM` (Value: `0x00020002`): System temperature.
* `SUSI_ID_HWM_TEMP_CPU2` (Value: `0x00020003`): Second CPU temperature (if applicable).
* `SUSI_ID_HWM_TEMP_OEM0` (Value: `0x00020004`) to `SUSI_ID_HWM_TEMP_OEM5` (Value: `0x00020009`): Other temperature sensors.


**Thermal Protection Configuration Structure:**

```c
typedef struct _SusiThermalProtect {
    uint32_t SourceId;                // Thermal source ID (See "Hardware Monitor (HWM) Value IDs" below)
    uint32_t EventType;               // Thermal protection event type (See "Thermal Protection Event Types" above)
    uint32_t SendEventTemperature;    // Temperature (0.1 Kelvins) to trigger the event
    uint32_t ClearEventTemperature;   // Temperature (0.1 Kelvins) to clear the event
} SusiThermalProtect, *PSusiThermalProtect;
```

**Example Usage:**

```c
SusiThermalProtect config;
config.SourceId = SUSI_ID_HWM_TEMP_CPU;              // Monitor CPU temperature
config.EventType = SUSI_THERMAL_EVENT_THROTTLE;      // Trigger CPU throttling
config.SendEventTemperature = 350;                 // Trigger at 80.0Â°C (350 / 10 Kelvins)
config.ClearEventTemperature = 340;                 // Clear at 70.0Â°C (340 / 10 Kelvins)

uint32_t result = SusiThermalProtectionSetConfig(SUSI_ID_THERMAL_PROTECT_1, &config);
if (result == SUSI_STATUS_SUCCESS)
{
    // Thermal protection settings were applied successfully.
}
```

### 3.10.3 SusiThermalProtectionGetConfig

```c
uint32_t SUSI_API SusiThermalProtectionGetConfig(uint32_t Id, SusiThermalProtect *pConfig)
```

**Description:** Retrieves the current thermal protection configuration for the specified zone.

**Parameters:**

* **`Id`**: Selects the target thermal protection zone. Refer to the "Thermal Protection IDs" list in section 3.10 for possible values.
* **`pConfig`**:  A pointer to a `SusiThermalProtect` structure. The function will fill this structure with the current configuration settings for the specified thermal zone.

**Return Status Code:**

* `SUSI_STATUS_SUCCESS` (0): The current thermal protection configuration was successfully retrieved.
* `SUSI_STATUS_NOT_INITIALIZED` (0xFFFFFFFF): The SUSI API library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (0xFFFFFEFF):  An invalid parameter was passed to the function (e.g., `pConfig` is `NULL`).
* `SUSI_STATUS_UNSUPPORTED` (0xFFFFFCFF): The specified `Id` is not supported by the platform.

**Thermal Protection IDs:**

* `SUSI_ID_THERMAL_PROTECT_1` (Value: `0`): Thermal protection zone 1.
* `SUSI_ID_THERMAL_PROTECT_2` (Value: `1`): Thermal protection zone 2.
* `SUSI_ID_THERMAL_PROTECT_3` (Value: `2`): Thermal protection zone 3.
* `SUSI_ID_THERMAL_PROTECT_4` (Value: `3`): Thermal protection zone 4.

**Example Usage:**

```c
SusiThermalProtect config;
uint32_t result = SusiThermalProtectionGetConfig(SUSI_ID_THERMAL_PROTECT_1, &config);
if (result == SUSI_STATUS_SUCCESS)
{
    // config now holds the current thermal protection settings for zone 1.
}
```


### 3.11.1 SusiBoardGetValue (OOB Network)

```c
uint32_t SUSI_API SusiBoardGetValue(uint32_t Id, uint32_t *pValue)
```

**Description:** Retrieves various OOB network-related values depending on the `Id` parameter. The `pValue` parameter can be a single `uint32_t` or an array to accommodate different data sizes as specified in the "OOB Network ID" list below.

**Parameters:**

* **`Id`**: Selects the target OOB network value to retrieve.  See the "OOB Network ID" list below for available options.
* **`pValue`**:  A pointer to a `uint32_t` variable or an array of `uint32_t` variables to receive the requested data. The required size of `pValue` depends on the `Id` and is also specified in the "OOB Network ID" list.

**OOB Network ID:**

* `SUSI_ID_NETWORK_CONTROL` (Size: 1, Read/Write):  Used to control the network mode. See the "OOB Network Control" list in section 3.11 for possible control codes.
* `SUSI_ID_NETWORK_STATUS` (Size: 1, Read/Write):  Retrieves the current network status. See the "OOB Network Status" table in section 3.11 for bit definitions.
* `SUSI_ID_NETWORK_HOST_NAME` (Size: 32, Read/Write): Retrieves or sets the network hostname. 
* `SUSI_ID_NETWORK_MAC_ADDRESS` (Size: 6, Read/Write): Retrieves or sets the Ethernet MAC address.
* `SUSI_ID_NETWORK_M_DEVICE_IP` (Size: 4, Read/Write): Retrieves or sets the modified static IP address.
* `SUSI_ID_NETWORK_M_SUB_MASK` (Size: 4, Read/Write): Retrieves or sets the modified subnet mask.
* `SUSI_ID_NETWORK_M_DOMAIN_NAME_SERVER_IP` (Size: 4, Read/Write): Retrieves or sets the modified domain name server IP address.
* `SUSI_ID_NETWORK_M_GATEWAY_IP` (Size: 4, Read/Write): Retrieves or sets the modified gateway IP address.
* `SUSI_ID_NETWORK_C_DEVICE_IP` (Size: 4, Read-Only): Retrieves the current IP address (either static or DHCP-assigned).
* `SUSI_ID_NETWORK_C_SUB_MASK` (Size: 4, Read-Only): Retrieves the current subnet mask.
* `SUSI_ID_NETWORK_C_DOMAIN_NAME_SERVER_IP` (Size: 4, Read-Only): Retrieves the current domain name server IP address.
* `SUSI_ID_NETWORK_C_GATEWAY_IP` (Size: 4, Read-Only): Retrieves the current gateway IP address.
* `SUSI_ID_NETWORK_ERROR_CODE` (Size: 1, Read-Only): Retrieves the network error code.
* `SUSI_ID_NETWORK_SERVER_TYPE` (Size: 1, Read-Only): Retrieves the current server type.  See the "OOB Network Server Type" list in section 3.11 for possible values.
* `SUSI_ID_NETWORK_SERVER_DOMAIN_NAME` (Size: 64, Read-Only):  Retrieves the server domain name. 
* `SUSI_ID_NETWORK_SERVER_IP_PORT` (Size: 5, Read-Only): Retrieves the server IP address and port.

**Return Status Code:**

* `SUSI_STATUS_SUCCESS` (0): The OOB network value was successfully retrieved.
* `SUSI_STATUS_NOT_INITIALIZED` (0xFFFFFFFF): The SUSI API library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (0xFFFFFEFF): An invalid parameter was passed to the function (e.g., `pValue` is `NULL`).
* `SUSI_STATUS_UNSUPPORTED` (0xFFFFFCFF): The specified `Id` is not supported by the platform.

### 3.11.1 SusiBoardGetValue (OOB Network part2)

SusiBoardGetValue : Retrieves various OOB network-related values depending on the `Id` parameter. The `pValue` parameter can be a single `uint32_t` or an array to accommodate different data sizes as specified in the "OOB Network ID" list below.

**OOB Network Control Codes:**

* `0x00`: Disconnect LAN.
* `0x01`: Connect LAN with Static IP. All network settings must be completed first.
* `0x02`: Connect LAN with DHCP server.
* `0x10`: Store all modified settings to flash.
* `0x11`: Restore all modified settings.
* `0x12`: Reload factory settings from flash.

**OOB Network Status Bits:**

* Bit 7: Network Interface Type
    * 0: Dedicated LAN Port
    * 1: NCSI Side-band Port
* Bit 6: Remote server connected
    * 0: Disconnected
    * 1: Connected
* Bit 5: IP address
    * 0: Invalid
    * 1: Valid
* Bit 4: IP source
    * 0: Static IP
    * 1: DHCP Server
* Bit 3: Link status
    * 0: Link-down
    * 1: Link-up
* Bit 2: Network enabled
    * 0: Disabled
    * 1: Enabled
* Bit 1: Network setting modify
    * 0: No modify
    * 1: Modify
* Bit 0: Network Available
    * 0: Non-available
    * 1: Available

**OOB Network Server Types:**

* `0x00`: No Provision.
* `0x01`: NMC server.
* `0x02`: DeviceOn server.


**Example Usage:**

```c
uint32_t networkStatus;
uint32_t result = SusiBoardGetValue(SUSI_ID_NETWORK_STATUS, &networkStatus);
if (result == SUSI_STATUS_SUCCESS)
{
   // Process networkStatus value (refer to "OOB Network Status" table).
}

uint32_t ipAddress[4];
result = SusiBoardGetValue(SUSI_ID_NETWORK_C_DEVICE_IP, ipAddress);
if (result == SUSI_STATUS_SUCCESS)
{
    // ipAddress now contains the current IP address. 
} 


### 3.11.2 SusiBoardSetValue (OOB Network)

```c
uint32_t SUSI_API SusiBoardSetValue(uint32_t Id, uint32_t *pValue)
```

**Description:** Sets various OOB network-related values depending on the `Id` parameter. Similar to `SusiBoardGetValue`, the `pValue` parameter can be a single `uint32_t` or an array to accommodate different data sizes as specified in the "OOB Network ID" list. Only IDs marked as Read/Write in the list can be set using this function.

**Parameters:**

* **`Id`**: Selects the target OOB network value to set. Refer to the "OOB Network ID" list . Only IDs marked as Read/Write can be set.
* **`pValue`**: A pointer to a `uint32_t` variable or an array of `uint32_t` variables containing the data to be set. The required size of `pValue` depends on the `Id` and is specified in the "OOB Network ID" list.

**Return Status Code:**

* `SUSI_STATUS_SUCCESS` (0): The OOB network value was successfully set.
* `SUSI_STATUS_NOT_INITIALIZED` (0xFFFFFFFF): The SUSI API library is not initialized.
* `SUSI_STATUS_INVALID_PARAMETER` (0xFFFFFEFF): An invalid parameter was passed to the function (e.g., `pValue` is `NULL`).
* `SUSI_STATUS_UNSUPPORTED` (0xFFFFFCFF): The specified `Id` is not supported by the platform or is read-only.

**OOB Network ID:**

* `SUSI_ID_NETWORK_CONTROL` (Size: 1, Read/Write):  Used to control the network mode. See the "OOB Network Control" list in section 3.11 for possible control codes.
* `SUSI_ID_NETWORK_STATUS` (Size: 1, Read/Write):  Retrieves the current network status. See the "OOB Network Status" table in section 3.11 for bit definitions.
* `SUSI_ID_NETWORK_HOST_NAME` (Size: 32, Read/Write): Retrieves or sets the network hostname. 
* `SUSI_ID_NETWORK_MAC_ADDRESS` (Size: 6, Read/Write): Retrieves or sets the Ethernet MAC address.
* `SUSI_ID_NETWORK_M_DEVICE_IP` (Size: 4, Read/Write): Retrieves or sets the modified static IP address.
* `SUSI_ID_NETWORK_M_SUB_MASK` (Size: 4, Read/Write): Retrieves or sets the modified subnet mask.
* `SUSI_ID_NETWORK_M_DOMAIN_NAME_SERVER_IP` (Size: 4, Read/Write): Retrieves or sets the modified domain name server IP address.
* `SUSI_ID_NETWORK_M_GATEWAY_IP` (Size: 4, Read/Write): Retrieves or sets the modified gateway IP address.
* `SUSI_ID_NETWORK_C_DEVICE_IP` (Size: 4, Read-Only): Retrieves the current IP address (either static or DHCP-assigned).
* `SUSI_ID_NETWORK_C_SUB_MASK` (Size: 4, Read-Only): Retrieves the current subnet mask.
* `SUSI_ID_NETWORK_C_DOMAIN_NAME_SERVER_IP` (Size: 4, Read-Only): Retrieves the current domain name server IP address.
* `SUSI_ID_NETWORK_C_GATEWAY_IP` (Size: 4, Read-Only): Retrieves the current gateway IP address.
* `SUSI_ID_NETWORK_ERROR_CODE` (Size: 1, Read-Only): Retrieves the network error code.
* `SUSI_ID_NETWORK_SERVER_TYPE` (Size: 1, Read-Only): Retrieves the current server type.  See the "OOB Network Server Type" list in section 3.11 for possible values.
* `SUSI_ID_NETWORK_SERVER_DOMAIN_NAME` (Size: 64, Read-Only):  Retrieves the server domain name. 
* `SUSI_ID_NETWORK_SERVER_IP_PORT` (Size: 5, Read-Only): Retrieves the server IP address and port.


**Example Usage:**

```c
uint32_t newNetworkControl = 0x01; // Connect using static IP
uint32_t result = SusiBoardSetValue(SUSI_ID_NETWORK_CONTROL, &newNetworkControl);
if (result == SUSI_STATUS_SUCCESS)
{
    // Network mode changed to static IP.
}

uint32_t newIpAddress[4] = {192, 168, 1, 100};
result = SusiBoardSetValue(SUSI_ID_NETWORK_M_DEVICE_IP, newIpAddress);
if (result == SUSI_STATUS_SUCCESS)
{
    // Modified static IP address set to 192.168.1.100.
}
``` 



### 4.1 Limitation

The SUSI API, while providing a unified interface for hardware access, can encounter limitations when interacting with other drivers or applications that directly access the same hardware resources. This is particularly relevant when dealing with legacy drivers or those that bypass the standard OS mechanisms for hardware access.

### 4.2 Case Study: Nuvoton COM Port

This case study illustrates a scenario where potential conflicts can arise between the SUSI API and a vendor-supplied COM port driver for a Nuvoton Super IO chip.

Description: The Nuvoton Super IO chip uses logical devices to manage various hardware functions, including GPIO and COM ports.  For example, logical device 07 in the Super IO's register space controls GPIO groups 4 and 5.  Registers 0xF0 and 0xF1 control the direction and level of GPIO group 4, while registers 0xF4 and 0xF5 control group 5.

When the SUSI API is used to control GPIO group 4 and a separate application uses the vendor's COM port driver, conflicts can occur. The vendor's driver might modify the values in registers 0x30, 0xF0, and 0xF1, which are also used by the SUSI driver for GPIO control. This can lead to unexpected behavior and data corruption.

Analysis :The root of the conflict lies in the way the vendor's COM port driver interacts with the Super IO chip.  The driver directly modifies registers related to COM port configuration, including those used for GPIO control. This direct access can bypass any protection mechanisms implemented by the SUSI driver.

Conclusion:To mitigate these conflicts, it's crucial to implement proper synchronization mechanisms between the SUSI API and the vendor's driver. One approach is to use mutexes (mutual exclusion objects) to ensure that only one application can access the shared hardware resources at a time.

### 4.2 SUSI API mutex example

```c
CMutex mutex(FALSE, "SUSI_COM_MUTEX"); // Create a mutex object named "SUSI_COM_MUTEX"

// Initialize SUSI library
mutex.Lock();
status = SusiLibInitialize();
mutex.Unlock();

// Get watchdog reset minimum time
mutex.Lock();
SusiWDogGetCaps(SUSI_ID_WATCHDOG_1, SUSI_ID_WDT_RESET_MINIMUM, &wdt_info);
mutex.Unlock();

// Start watchdog with specified parameters
mutex.Lock();
status = SusiWDogStart(SUSI_ID_WATCHDOG_1, 0, 0, 255000, SUSI_WDT_EVENT_TYPE_NONE); 
mutex.Unlock();

// Stop watchdog
mutex.Lock();
SusiWDogStop(SUSI_ID_WATCHDOG_1);
mutex.Unlock();

// Set GPIO level
mutex.Lock();
status = SusiGPIOSetLevel(2, 1, 0); // Set GPIO pin 2 (assuming bank mode) to level 0
mutex.Unlock();

// Get GPIO level
mutex.Lock();
SusiGPIOGetLevel(0, 1, &value); // Get the level of GPIO pin 0 (assuming bank mode)
mutex.Unlock();

// Uninitialize SUSI library
mutex.Lock();
status = SusiLibUninitialize();
mutex.Unlock();
```

**Explanation:**

* Each SUSI API call is enclosed within a critical section protected by the `mutex` object.
* `mutex.Lock()` acquires the mutex, ensuring exclusive access to the shared hardware resources.
* `mutex.Unlock()` releases the mutex, allowing other applications to access the resources.
* This code demonstrates how to use mutexes to synchronize access to GPIO and watchdog resources, preventing conflicts with other applications that might be using the same hardware. 

### 4.3 COM API mutex example

```c
CMutex mutex(FALSE, "SUSI_COM_MUTEX"); // Create a mutex object named "SUSI_COM_MUTEX"

// COM open
mutex.Lock(); // Acquire the mutex to ensure exclusive access
com1_handle = CreateFile("COM1", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL); // Open COM1 with overlapped I/O
mutex.Unlock(); // Release the mutex

if (com1_handle != INVALID_HANDLE_VALUE) // Check if COM1 opened successfully
{
    // COM parameter get
    DCB dcb; // Device Control Block for COM port configuration
    if (GetCommState(com1_handle, &dcb) != 0) // Get current COM port settings
    {
        dcb.DCBlength = sizeof(dcb); // Set the size of the DCB structure
        dcb.BaudRate = CBR_9600; // Set baud rate to 9600
        dcb.ByteSize = 8; // Set data bits to 8
        dcb.Parity = NOPARITY; // Set parity to none
        dcb.StopBits = ONESTOPBIT; // Set stop bits to 1

        // Set flow control parameters
        dcb.fDtrControl = DTR_CONTROL_ENABLE; // Enable DTR flow control
        dcb.fRtsControl = RTS_CONTROL_ENABLE; // Enable RTS flow control
        dcb.fTXContinueOnXoff = TRUE; // Continue transmitting even if XOFF is received
        dcb.fOutX = FALSE; // Disable XON/XOFF output flow control
        dcb.fInX = FALSE; // Disable XON/XOFF input flow control
        dcb.fOutxDsrFlow = TRUE; // Enable DSR output flow control

        // COM parameter set
        if (SetCommState(com1_handle, &dcb) != 0) // Apply the new COM port settings
        {
            // COM timeouts
            COMMTIMEOUTS timeouts; // Structure for COM port timeout settings
            timeouts.ReadIntervalTimeout = 0; // Set read interval timeout to 0
            timeouts.ReadTotalTimeoutMultiplier = 0; // Set read total timeout multiplier to 0
            timeouts.ReadTotalTimeoutConstant = 0; // Set read total timeout constant to 0
            timeouts.WriteTotalTimeoutMultiplier = 0; // Set write total timeout multiplier to 0
            timeouts.WriteTotalTimeoutConstant = 0; // Set write total timeout constant to 0

            // COM parameter set
            if (SetCommTimeouts(com1_handle, &timeouts) != 0) // Apply the new timeout settings
            {
                printf("com1 SetCommTimeouts\n"); // Print a message if successful
            }
        }
    }
}

// COM close
mutex.Lock(); // Acquire the mutex before closing the COM port
if (com1_handle != INVALID_HANDLE_VALUE) // Check if the COM port handle is valid
{
    BOOL rc = CloseHandle(com1_handle); // Close the COM port handle
    mutex.Unlock(); // Release the mutex after closing the COM port
}
```

**Explanation:**

* The code demonstrates how to open, configure, and close a COM port (COM1 in this case) using Windows API functions.
* It uses a mutex (`SUSI_COM_MUTEX`) to protect the COM port operations from concurrent access by other applications, ensuring thread safety.
* The code sets various COM port parameters like baud rate, data bits, parity, stop bits, and flow control settings using the `DCB` (Device Control Block) structure.
* It also configures COM port timeouts using the `COMMTIMEOUTS` structure.
* The `CreateFile`, `GetCommState`, `SetCommState`, `SetCommTimeouts`, and `CloseHandle` functions are standard Windows API functions for COM port management. 



### 5.1 OverviewA: Using SMBus with SUSI
SMBus summary
SUSI provides a set of functions for interacting with SMBus devices. These functions allow you to perform various operations, including:
(Use SusiBoardGetValue to know smbus support or not.)

* **Reading and writing bytes and words:** `SusiSMBReadByte`, `SusiSMBWriteByte`, `SusiSMBReadWord`, `SusiSMBWriteWord`
* **Sending and receiving bytes:** `SusiSMBSendByte`, `SusiSMBReceiveByte`
* **Performing quick read and write operations:** `SusiSMBReadQuick`, `SusiSMBWriteQuick`
* **Reading and writing blocks of data:** `SusiSMBReadBlock`, `SusiSMBWriteBlock`
* **Reading and writing blocks of data using the I2C block protocol:** `SusiSMBI2CReadBlock`, `SusiSMBI2CWriteBlock`

Each of these functions requires you to specify the SMBus device ID (`Id`) and the slave address (`Addr`) of the target device. You may also need to provide a command or register offset (`Cmd`) depending on the specific operation.
SUSI supports multiple SMBus devices, identified by unique IDs. You can use the `SusiBoardGetValue` function with the `SUSI_ID_SMBUS_SUPPORTED` ID to retrieve a bitmask indicating which SMBus devices are available on the system.
The order in which you use different SMBus devices is determined by your application's needs. There are no inherent restrictions on the order of access. However, it's important to ensure that you're using the correct device ID and slave address for each operation to avoid communication errors.

**Example Usage Logic**

Here's a general logic flow for using SMBus functions(susi4.h):

1. **Initialize the SUSI library:** Call `SusiLibInitialize` before using any other SUSI functions.
2. **Identify available SMBus devices:** Use `SusiBoardGetValue` with `SUSI_ID_SMBUS_SUPPORTED` to determine which devices are present.
3. **Select the target device:** Choose the appropriate SMBus device ID based on your application's requirements.
4. **Perform SMBus operations:** Use the relevant SUSI functions to read, write, or control the target device.
5. **Uninitialize the SUSI library:** Call `SusiLibUninitialize` when you're finished using the library.

Remember to consult the SUSI API documentation for detailed information on each function and its parameters. 





### 5.2 Overview B:  Controlling GPIO with SUSI

SUSI provides a set of functions for interacting with GPIO pins. These functions allow you to:

* **Query GPIO capabilities:** `SusiGPIOGetCaps` tells you which GPIO pins support input or output functionality.
* **Set GPIO direction:** `SusiGPIOSetDirection` configures a GPIO pin as either an input or an output.
* **Read GPIO level:** `SusiGPIOGetLevel` reads the logic level (high:1 or low:0) of a GPIO pin.
* **Set GPIO level:** `SusiGPIOSetLevel` sets the logic level of a GPIO pin to high or low.

The typical order of using GPIO functions is as follows:

1. **Initialize the SUSI library:** Call `SusiLibInitialize` before using any other SUSI functions.
2. **Query GPIO capabilities:** Use `SusiGPIOGetCaps` to check if the GPIO pin you want to use supports the functionality you need.
3. **Set GPIO direction:** Use `SusiGPIOSetDirection` to configure the GPIO pin as either an input or an output.
4. **Read or set GPIO level:** Depending on your application, use `SusiGPIOGetLevel` to read the state of the GPIO pin, or use `SusiGPIOSetLevel` to set the state of the GPIO pin.
5. **Uninitialize the SUSI library:** Call `SusiLibUninitialize` when you're finished using the library.

**Example**
Let's say you want to control an LED using GPIO pin 12:

1. **Initialize the SUSI library.**
2. **Use `SusiGPIOGetCaps` to check if GPIO pin 12 supports output functionality.**
3. **Use `SusiGPIOSetDirection` to configure GPIO pin 12 as an output.**
4. **Use `SusiGPIOSetLevel` to set GPIO pin 12 to high to turn on the LED.**
5. **Use `SusiGPIOSetLevel` to set GPIO pin 12 to low to turn off the LED.**
6. **Uninitialize the SUSI library.**

Remember that the SUSI API documentation provides detailed information on each function and its parameters. 



### 5.3 Overview C: Using I2C with SUSI

SUSI provides a set of functions for communicating with I2C devices. These functions handle the low-level details of the I2C protocol, making it easier for developers to interact with I2C peripherals. Here are some key functions:
(Use SusiBoardGetValue to know i2c support or not.SUSI_ID_I2C_SUPPORTED` (Value: `0x00030100`))

* **`SusiI2CGetCaps`:** Retrieves the capabilities of the I2C controller, such as the maximum supported block length.
* **`SusiI2CWriteReadCombine`:** Performs a combined write and read operation, allowing you to write data to a device and then immediately read data back without releasing the bus.
* **`SusiI2CReadTransfer`:** Reads data from a specific register within the selected I2C device.
* **`SusiI2CWriteTransfer`:** Writes data to a specific register within the selected I2C device.
* **`SusiI2CProbeDevice`:** Checks if a device with a specific I2C address is present on the bus.
* **`SusiI2CGetFrequency`:** Retrieves the current I2C clock frequency.
* **`SusiI2CSetFrequency`:** Sets the I2C clock frequency.

The typical order of using I2C functions with SUSI is as follows:

1. **Initialize the SUSI library:** Call `SusiLibInitialize` before using any other SUSI functions.
2. **(Optional) Get I2C controller capabilities:** Use `SusiI2CGetCaps` to retrieve information about the I2C controller, such as the maximum block length.
3. **(Optional) Probe for the device:** Use `SusiI2CProbeDevice` to check if the target I2C device is present on the bus.
4. **(Optional) Set I2C frequency:** Use `SusiI2CSetFrequency` to configure the desired I2C clock frequency if needed.
5. **Perform I2C operations:** Use `SusiI2CWriteReadCombine`, `SusiI2CReadTransfer`, or `SusiI2CWriteTransfer` to interact with the I2C device.
6. **Uninitialize the SUSI library:** Call `SusiLibUninitialize` when you're finished using the library.

**Example: Reading Data from a Temperature Sensor**

Let's say you have a temperature sensor connected to the I2C bus with address 0x48, and you want to read the temperature value from register 0x00:

1. **Initialize the SUSI library.**
2. **(Optional) Probe for the sensor:** Use `SusiI2CProbeDevice` with address 0x48 to ensure the sensor is present.
3. **Read temperature data:** Use `SusiI2CReadTransfer` with the device address (0x48), register address (0x00), and a buffer to store the read data.
4. **Process the temperature data:** Convert the raw data from the buffer into a meaningful temperature value based on the sensor's datasheet.
5. **Uninitialize the SUSI library.**

Remember to consult the SUSI API documentation and the datasheet of your I2C device for specific details on how to interact with it. 



### 5.4 Overview D: Using Watchdog Timers with SUSI

SUSI provides functions to control and configure watchdog timers. Here's a breakdown of the key functions:

* **`SusiWDogGetCaps`:** Retrieves the capabilities of the watchdog timer, such as supported event types, minimum and maximum timeout values, etc.
* **`SusiWDogStart`:** Starts the watchdog timer with specified delay, event, and reset times, as well as the type of event to trigger.
* **`SusiWDogStop`:** Stops the watchdog timer, preventing it from triggering a reset.
* **`SusiWDogTrigger`:** "Pets" or "kicks" the watchdog timer, resetting its internal counter and preventing a timeout.
* **`SusiWDogSetCallBack`:** Sets a callback function to be called when an IRQ event is triggered by the watchdog timer.


Here's the typical order of using watchdog timer functions with SUSI:

1. **Initialize the SUSI library:** Call `SusiLibInitialize` before using any other SUSI functions.
2. **Get watchdog capabilities:** Use `SusiWDogGetCaps` to understand the watchdog timer's features and limitations.
3. **Start the watchdog timer:** Use `SusiWDogStart` to configure and start the timer with appropriate timeout values and event type.
4. **Periodically trigger the watchdog:** In your main application loop, regularly call `SusiWDogTrigger` to reset the timer and prevent a timeout. This indicates that your system is still responsive.
5. **(Optional) Set a callback function:** If you want to perform specific actions when a watchdog event occurs (before a reset), use `SusiWDogSetCallBack` to register a callback function.
6. **(Optional) Stop the watchdog timer:** If needed, use `SusiWDogStop` to disable the watchdog timer.
7. **Uninitialize the SUSI library:** Call `SusiLibUninitialize` when you're finished using the library.

Example: Basic Watchdog Implementation

<C code>
// Initialize SUSI library
SusiLibInitialize();

// Get watchdog reset minimum time
uint32_t minResetTime;
SusiWDogGetCaps(SUSI_ID_WATCHDOG_1, SUSI_ID_WDT_RESET_MINIMUM, &minResetTime);

// Start watchdog with a 5-second reset timeout
SusiWDogStart(SUSI_ID_WATCHDOG_1, 0, 0, 5000, SUSI_WDT_EVENT_TYPE_NONE); 

// Main application loop
while (true) {
  // Perform your application tasks here

  // Trigger the watchdog every 2 seconds
  SusiWDogTrigger(SUSI_ID_WATCHDOG_1); 
  sleep(2000); 
}

// Stop watchdog (this line will likely never be reached if the loop is running properly)
SusiWDogStop(SUSI_ID_WATCHDOG_1);

// Uninitialize SUSI library
SusiLibUninitialize();
<code end>



### 5.5 Overview E: Using Hardware Monitor with SUSI

SUSI provides functions to access and retrieve data from the Hardware Monitor,including fan speed, temperature, voltage, etc.". The primary function for this is:

* **`SusiBoardGetValue`:** This function is used to retrieve a wide range of system information, including values from the Hardware Monitor. You need to provide the specific ID of the parameter you want to read.

Here's the typical order of using Hardware Monitor functions with SUSI:

1. **Initialize the SUSI library:** Call `SusiLibInitialize` before using any other SUSI functions.
2. **Identify the desired parameter ID:** Refer to the SUSI API documentation to find the specific ID for the parameter you want to monitor (e.g., `SUSI_ID_HWM_TEMP_CPU` for CPU temperature).
3. **Retrieve the parameter value:** Use `SusiBoardGetValue` with the identified parameter ID to read the current value.
4. **Process the data:** Interpret the retrieved value based on the parameter's units and range (e.g., convert raw temperature data to Celsius or Fahrenheit).
5. **(Optional) Repeat for other parameters:** If you need to monitor multiple parameters, repeat steps 2-4 for each parameter.
6. **Uninitialize the SUSI library:** Call `SusiLibUninitialize` when you're finished using the library.

Example: 
<C code>
// Initialize SUSI library
SusiLibInitialize();

// Retrieve CPU fan speed
uint32_t cpuFanSpeed;
SusiBoardGetValue(SUSI_ID_HWM_FAN_CPU, &cpuFanSpeed);

// Print CPU fan speed
printf("CPU Fan Speed: %u RPM\n", cpuFanSpeed);

// Uninitialize SUSI library
SusiLibUninitialize();
<end code>


### 5.6 Overview F:  Using Backlight Control with SUSI

SUSI provides functions to control the backlight of integrated flat panel displays, typically those using LVDS (Low-Voltage Differential Signaling) interfaces. Here are the key functions:

* **`SusiVgaGetCaps`:** Retrieves the capabilities of the backlight controller, such as the maximum and minimum brightness levels.
* **`SusiVgaGetBacklightEnable`:** Checks if the backlight is currently enabled (on) or disabled (off).
* **`SusiVgaSetBacklightEnable`:** Turns the backlight on or off.
* **`SusiVgaGetBacklightBrightness`:** Retrieves the current backlight brightness level.
* **`SusiVgaSetBacklightBrightness`:** Sets the backlight brightness to a specific level.
* **`SusiVgaGetBacklightLevel`:** Retrieves the current backlight brightness level as a discrete level (often represented as a number from 0 to 9).
* **`SusiVgaSetBacklightLevel`:** Sets the backlight brightness to a specific discrete level.
* **`SusiVgaGetPolarity`:** Retrieves the polarity of the backlight signal (on or off).
* **`SusiVgaSetPolarity`:** Sets the polarity of the backlight signal.
* **`SusiVgaGetFrequency`:** Retrieves the frequency of the backlight PWM (Pulse Width Modulation) signal.
* **`SusiVgaSetFrequency`:** Sets the frequency of the backlight PWM signal.

Here's the typical order of using backlight control functions with SUSI:

1. **Initialize the SUSI library:** Call `SusiLibInitialize` before using any other SUSI functions.
2. **(Optional) Get backlight capabilities:** Use `SusiVgaGetCaps` to understand the backlight controller's features and limitations, such as the brightness range.
3. **Control backlight state:** Use `SusiVgaGetBacklightEnable` and `SusiVgaSetBacklightEnable` to check and control the on/off state of the backlight.
4. **Adjust backlight brightness:** Use `SusiVgaGetBacklightBrightness` and `SusiVgaSetBacklightBrightness` (or `SusiVgaGetBacklightLevel` and `SusiVgaSetBacklightLevel`) to retrieve and set the backlight brightness.
5. **(Optional) Configure advanced settings:** If needed, use `SusiVgaGetPolarity`, `SusiVgaSetPolarity`, `SusiVgaGetFrequency`, and `SusiVgaSetFrequency` to adjust the backlight signal polarity and PWM frequency.
6. **Uninitialize the SUSI library:** Call `SusiLibUninitialize` when you're finished using the library.

Example: Setting Backlight Brightness

<C code>
// Initialize SUSI library
SusiLibInitialize();

// Get maximum brightness level
uint32_t maxBrightness;
SusiVgaGetCaps(SUSI_ID_BACKLIGHT_1, SUSI_ID_VGA_BRIGHTNESS_MAXIMUM, &maxBrightness);

// Set backlight brightness to 50%
uint32_t brightnessLevel = maxBrightness / 2;
SusiVgaSetBacklightBrightness(SUSI_ID_BACKLIGHT_1, brightnessLevel);

//Set the backlight brightness level:** Use the `SusiVgaSetBacklightLevel` function to set the backlight brightness level. The brightness level is typically between 0 and 9, where 0 is the darkest and 9 is the brightest.
uint32_t brightnessLevel = 5; // Set to medium brightness
SusiVgaSetBacklightLevel(SUSI_ID_BACKLIGHT_1, brightnessLevel);

// Uninitialize SUSI library
SusiLibUninitialize();
<code end>


### 5.7 Overview G:  Using Storage with SUSI

SUSI provides functions to access and manage non-volatile storage areas. These functions allow you to:

* **Query storage capabilities:** `SusiStorageGetCaps` retrieves information about the storage device, such as total size, block size, and lock status.
* **Read data from storage:** `SusiStorageAreaRead` reads a block of data from a specific offset within the storage area.
* **Write data to storage:** `SusiStorageAreaWrite` writes a block of data to a specific offset within the storage area.
* **Lock storage area:** `SusiStorageAreaSetLock` prevents further write operations to the storage area, protecting data from accidental modification.
* **Unlock storage area:** `SusiStorageAreaSetUnlock` removes write protection, allowing data to be modified again.

Here's the typical order of using storage functions with SUSI:

1. **Initialize the SUSI library:** Call `SusiLibInitialize` before using any other SUSI functions.
2. **(Optional) Get storage capabilities:** Use `SusiStorageGetCaps` to understand the storage device's characteristics, such as total size and block size.
3. **(Optional) Lock/Unlock storage area:** If needed, use `SusiStorageAreaSetLock` or `SusiStorageAreaSetUnlock` to control write protection for the storage area.
4. **Read or write data:** Use `SusiStorageAreaRead` to retrieve data from storage or `SusiStorageAreaWrite` to store data.
5. **Uninitialize the SUSI library:** Call `SusiLibUninitialize` when you're finished using the library.

Example: Storing and Retrieving User Settings

<C code>
// Initialize SUSI library
SusiLibInitialize();

// Define a structure to hold user settings
typedef struct {
  int brightness;
  bool soundEnabled;
} UserSettings;

// Create an instance of UserSettings
UserSettings settings;

// Read settings from storage (assuming offset 0)
uint32_t bytesRead = sizeof(UserSettings);
SusiStorageAreaRead(SUSI_ID_STORAGE_STD, 0, (uint8_t*)&settings, &bytesRead);

// Modify settings
settings.brightness = 75;
settings.soundEnabled = true;

// Write settings back to storage
uint32_t bytesWritten = sizeof(UserSettings);
SusiStorageAreaWrite(SUSI_ID_STORAGE_STD, 0, (uint8_t*)&settings, &bytesWritten);

// Uninitialize SUSI library
SusiLibUninitialize();
<code end>


### 5.8 Overview H:  Using Thermal Protection with SUSI

SUSI provides functions to configure and control thermal protection mechanisms. Here are the key functions:

* **`SusiThermalProtectionGetCaps`:** Retrieves the capabilities of the thermal protection system, such as supported event types and temperature ranges.
* **`SusiThermalProtectionSetConfig`:** Configures the thermal protection settings for a specific zone, defining the temperature source, event type, and temperature thresholds for triggering and clearing events.
* **`SusiThermalProtectionGetConfig`:** Retrieves the current thermal protection configuration for a specific zone.

Here's the typical order of using thermal protection functions with SUSI:

1. **Initialize the SUSI library:** Call `SusiLibInitialize` before using any other SUSI functions.
2. **(Optional) Get thermal protection capabilities:** Use `SusiThermalProtectionGetCaps` to understand the supported features and limitations of the thermal protection system.
3. **Configure thermal protection settings:** Use `SusiThermalProtectionSetConfig` to define the desired thermal protection behavior for each zone. This includes specifying the temperature source to monitor, the event type to trigger (e.g., shutdown, throttle), and the temperature thresholds for triggering and clearing the event.
4. **(Optional) Retrieve current configuration:** Use `SusiThermalProtectionGetConfig` to check the current thermal protection settings if needed.
5. **Uninitialize the SUSI library:** Call `SusiLibUninitialize` when you're finished using the library.

Example: Configuring CPU Thermal Throttling

<C code>
// Initialize SUSI library
SusiLibInitialize();

// Define thermal protection configuration
SusiThermalProtect cpuConfig;
cpuConfig.SourceId = SUSI_ID_HWM_TEMP_CPU; // Monitor CPU temperature
cpuConfig.EventType = SUSI_THERMAL_EVENT_THROTTLE; // Trigger CPU throttling
cpuConfig.SendEventTemperature = 353; // Trigger at 80Â°C (353 Kelvin)
cpuConfig.ClearEventTemperature = 343; // Clear at 70Â°C (343 Kelvin)

// Set thermal protection configuration for zone 1
SusiThermalProtectionSetConfig(SUSI_ID_THERMAL_PROTECT_1, &cpuConfig);

// Uninitialize SUSI library
SusiLibUninitialize();
<code end>



### 10.1.1   SusiBoardGetStringA C#  code

**Description:** This code snippet demonstrates how to retrieve a string value from the SusiBoard API. It first initializes a `StringBuilder` object with a specified length. Then, it calls the `SusiBoardGetStringA` function, passing in the query ID (`queryID`), the `StringBuilder` object, and a reference to the length variable. If the function call is successful, it extracts the string from the `StringBuilder` object and assigns it to the `_Name` variable.

**Parameters:**

- `queryID`: The ID of the string value to retrieve. This ID should correspond to one of the string constants defined in the `SusiBoard` class, such as `SUSI_ID_BOARD_MANUFACTURER_STR` or `SUSI_ID_BOARD_NAME_STR`.
- `sb`: A `StringBuilder` object that will store the retrieved string.
- `Length`: A reference to a `UInt32` variable that specifies the length of the `StringBuilder` object. After the function call, this variable will contain the actual length of the retrieved string.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To retrieve the board manufacturer string, you would use the following code:

<c# code>
UInt32 Length = 32;
UInt32 queryID = SusiBoard.SUSI_ID_BOARD_MANUFACTURER_STR;
StringBuilder sb = new StringBuilder((int)Length);

if (SusiBoard.SusiBoardGetStringA(queryID, sb, ref Length) == SusiStatus.SUSI_STATUS_SUCCESS)
{
    string boardManufacturer = sb.ToString();
    Console.WriteLine("Board Manufacturer: " + boardManufacturer);
}
else
{
    Console.WriteLine("Failed to retrieve board manufacturer string.");
}
<code end>

**Note:** The `SusiBoardGetStringA` function retrieves a string encoded in ANSI format. If you need to work with Unicode strings, you can use the `SusiBoardGetStringW` function instead.


### 10.1.1   SusiGPIOGetCaps C#  code

**Description:** This code snippet demonstrates how to initialize and retrieve the capabilities of GPIO (General Purpose Input/Output) pins using the SusiGPIO API. It iterates through a range of GPIO banks and retrieves the input, output, and interrupt support capabilities for each bank.

**Parameters:**

- `MAX_BANK_NUM`: The maximum number of GPIO banks.
- `DeviceInfo`: A custom class or structure that stores GPIO bank information, including input support, output support, and interrupt support.
- `ID`: The ID of the GPIO bank.
- `SusiGPIO.SUSI_ID_GPIO_INPUT_SUPPORT`: An item ID that specifies the input support capability.
- `SusiGPIO.SUSI_ID_GPIO_OUTPUT_SUPPORT`: An item ID that specifies the output support capability.
- `SusiGPIO.SUSI_ID_GPIO_INT_SUPPORT`: An item ID that specifies the interrupt support capability.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

<c# code>
// Define a custom class or structure to store GPIO bank information
public class DeviceInfo
{
    public UInt32 ID;
    public bool SupportInput;
    public bool SupportOutput;
    public bool SupportInterrupt;

    public DeviceInfo(UInt32 id)
    {
        ID = id;
    }
}

// Initialize GPIO banks
private void InitializeGPIO()
{
    UInt32 Status;

    // Assuming a maximum of 4 GPIO banks
    const int MAX_BANK_NUM = 4;

    for (int i = 0; i < MAX_BANK_NUM; i++)
    {
        DeviceInfo info = new DeviceInfo(SusiGPIO.SUSI_ID_GPIO_BANK((UInt32)i));

        // Get input support capability
        Status = SusiGPIO.SusiGPIOGetCaps(info.ID, SusiGPIO.SUSI_ID_GPIO_INPUT_SUPPORT, out info.SupportInput);
        if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to get input support for GPIO bank " + i);
            continue;
        }

        // Get output support capability
        Status = SusiGPIO.SusiGPIOGetCaps(info.ID, SusiGPIO.SUSI_ID_GPIO_OUTPUT_SUPPORT, out info.SupportOutput);
        if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to get output support for GPIO bank " + i);
            continue;
        }

        // Get interrupt support capability
        Status = SusiGPIO.SusiGPIOGetCaps(info.ID, SusiGPIO.SUSI_ID_GPIO_INT_SUPPORT, out info.SupportInterrupt);
        if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to get interrupt support for GPIO bank " + i);
            continue;
        }

        // Print GPIO bank information
        Console.WriteLine("GPIO Bank " + i + ":");
        Console.WriteLine("  Support Input: " + info.SupportInput);
        Console.WriteLine("  Support Output: " + info.SupportOutput);
        Console.WriteLine("  Support Interrupt: " + info.SupportInterrupt);
    }
}
<code end>


### 10.1.1 C# code GPIODirection C#  code

**Description:** This code snippet demonstrates how to get and set the direction of a GPIO (General Purpose Input/Output) pin using the SusiGPIO API. It first attempts to retrieve the current direction of the specified GPIO pin using `SusiGPIOGetDirection`. If successful, it then attempts to set the direction of the pin using `SusiGPIOSetDirection`.

**Parameters:**

- `ID`: The ID of the GPIO bank containing the pin.
- `Your_bitmask`: A bitmask indicating the specific pin within the bank. Each bit in the mask corresponds to a pin in the bank. For example, a bitmask of `0x01` would select the first pin, `0x02` would select the second pin, and so on.
- `Value`: A `UInt32` variable that will store the retrieved direction value (`SusiGPIO.SUSI_GPIO_INPUT` or `SusiGPIO.SUSI_GPIO_OUTPUT`) for `SusiGPIOGetDirection` and the desired direction value for `SusiGPIOSetDirection`.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To set the direction of the third pin in the first GPIO bank to output, you would use the following code:

<c# code>
UInt32 Status;
UInt32 Value;
UInt32 ID = SusiGPIO.SUSI_ID_GPIO_BANK(0); // First GPIO bank
UInt32 Your_bitmask = 0x04; // Third pin (0-indexed)

// Get the current direction
Status = SusiGPIO.SusiGPIOGetDirection(ID, Your_bitmask, out Value);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Current direction: " + (Value == SusiGPIO.SUSI_GPIO_INPUT ? "Input" : "Output"));
}
else
{
    Console.WriteLine("Failed to get GPIO direction.");
}

// Set the direction to output
Value = SusiGPIO.SUSI_GPIO_OUTPUT;
Status = SusiGPIO.SusiGPIOSetDirection(ID, Your_bitmask, Value);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to set GPIO direction.");
}
<code end>


### 10.1.1  GPIO level C#  code

**Description:** This code snippet demonstrates how to get and set the logic level of a GPIO (General Purpose Input/Output) pin using the SusiGPIO API. It first attempts to retrieve the current logic level of the specified GPIO pin using `SusiGPIOGetLevel`. If successful, it then attempts to set the logic level of the pin using `SusiGPIOSetLevel`.

**Parameters:**

- `ID`: The ID of the GPIO bank containing the pin.
- `Your_bitmask`: A bitmask indicating the specific pin within the bank. Each bit in the mask corresponds to a pin in the bank. For example, a bitmask of `0x01` would select the first pin, `0x02` would select the second pin, and so on.
- `Value`: A `UInt32` variable that will store the retrieved logic level value (`SusiGPIO.SUSI_GPIO_LOW` or `SusiGPIO.SUSI_GPIO_HIGH`) for `SusiGPIOGetLevel` and the desired logic level value for `SusiGPIOSetLevel`.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To set the logic level of the fifth pin in the second GPIO bank to high, you would use the following code:

<c# code>
UInt32 Status;
UInt32 Value;
UInt32 ID = SusiGPIO.SUSI_ID_GPIO_BANK(1); // Second GPIO bank
UInt32 Your_bitmask = 0x10; // Fifth pin (0-indexed)

// Get the current logic level
Status = SusiGPIO.SusiGPIOGetLevel(ID, Your_bitmask, out Value);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Current logic level: " + (Value == SusiGPIO.SUSI_GPIO_LOW ? "Low" : "High"));
}
else
{
    Console.WriteLine("Failed to get GPIO logic level.");
}

// Set the logic level to high
Value = SusiGPIO.SUSI_GPIO_HIGH;
Status = SusiGPIO.SusiGPIOSetLevel(ID, Your_bitmask, Value);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to set GPIO logic level.");
}
<code end>


###  10.0.1   SusiBoardGetValue C# code
**Use this function To know SMBUS support or not. To know I2C support or not. 
**Use this function to get fanspeed,such as ID:SUSI_ID_HWM_TEMP_CPU,SUSI_ID_HWM_FAN_CPU (replace your desired id)
**check the define in susi4.cs or define by yourself
**Description:** This code snippet demonstrates how to retrieve a numeric value from the SusiBoard API using the `SusiBoardGetValue` function. This function can be used for various purposes, such as checking for SMBus or I2C support, or retrieving hardware monitoring values like fan speed.

**Parameters:**

- `queryID`: The ID of the value to retrieve. This ID should correspond to one of the constants defined in the `SusiBoard` class, such as `SUSI_ID_SMBUS_SUPPORTED`, `SUSI_ID_I2C_SUPPORTED`, or `SUSI_ID_HWM_FAN_CPU`.
- `Value`: A reference to a `UInt32` variable that will store the retrieved value.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To retrieve the CPU fan speed, you would use the following code:

<c# code>
UInt32 Status;
UInt32 Value = 0;
UInt32 queryID = SusiBoard.SUSI_ID_HWM_FAN_CPU;

Status = SusiBoard.SusiBoardGetValue(queryID, ref Value);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("CPU Fan Speed: " + Value + " RPM");
}
else
{
    Console.WriteLine("Failed to retrieve CPU fan speed.");
}
<code end>

**Note:** The meaning of the retrieved value depends on the specific `queryID` used. Refer to the `SusiBoard` class documentation for the meaning of each constant.


###  10.0.1  SusiI2CGetFrequency C#  code
**Description:** This code snippet demonstrates how to retrieve the frequency of an I2C bus using the `SusiI2CGetFrequency` function from the SusiI2C API. 

**Parameters:**

- `queryID`: The ID of the I2C bus. This ID should correspond to one of the constants defined in the `SusiI2C` class, such as `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_I2C_OEM0`, etc.
- `Value`: A `UInt32` variable that will store the retrieved frequency value in Hz.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To retrieve the frequency of the external I2C bus, you would use the following code:

<c# code>
UInt32 Status;
UInt32 Value;
UInt32 queryID = SusiI2C.SUSI_ID_I2C_EXTERNAL;

Status = SusiI2C.SusiI2CGetFrequency(queryID, out Value);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("I2C Frequency: " + Value + " Hz");
}
else
{
    Console.WriteLine("Failed to retrieve I2C frequency.");
}
<code end>


###  10.0.1 SusiI2CSetFrequency C#  code
**Description:** This code snippet demonstrates how to set the frequency of an I2C bus using the `SusiI2CSetFrequency` function from the SusiI2C API. 

**Parameters:**

- `queryID`: The ID of the I2C bus. This ID should correspond to one of the constants defined in the `SusiI2C` class, such as `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_I2C_OEM0`, etc.
- `Value`: A `UInt32` variable containing the desired frequency value in Hz.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To set the frequency of the external I2C bus to 100 kHz, you would use the following code:

<c# code>
UInt32 Status;
UInt32 Value = 100000; // 100 kHz
UInt32 queryID = SusiI2C.SUSI_ID_I2C_EXTERNAL;

Status = SusiI2C.SusiI2CSetFrequency(queryID, Value);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to set I2C frequency.");
}
<code end>


###  10.0.1   SusiI2CWriteReadCombine C#  code
**Description:** This code snippet demonstrates how to perform a combined write-read operation on an I2C bus using the `SusiI2CWriteReadCombine` function from the SusiI2C API. This function allows you to send data to an I2C device and then immediately read data back from the device in a single transaction.

**Parameters:**

- `queryID`: The ID of the I2C bus. This ID should correspond to one of the constants defined in the `SusiI2C` class, such as `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_I2C_OEM0`, etc.
- `addr`: The 7-bit I2C address of the target device.
- `baData`: A byte array containing the data to be written to the device.
- `length`: The number of bytes to write from `baData`.
- `rData`: A byte array that will store the data read back from the device.
- `rlength`: The number of bytes to read into `rData`.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To write 3 bytes of data to an I2C device at address `0x50` and then read 2 bytes back, you would use the following code:

<c# code>
UInt32 Status;
UInt32 addr = 0x50;
byte[] baData = new byte[] { 0x01, 0x02, 0x03 };
UInt32 length = 3;
byte[] rData = new byte[2];
UInt32 rlength = 2;
UInt32 queryID = SusiI2C.SUSI_ID_I2C_EXTERNAL;

Status = SusiI2C.SusiI2CWriteReadCombine(queryID, (byte)addr, baData, length, rData, rlength);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to perform I2C write-read operation.");
}
else
{
    Console.WriteLine("Data read from device: " + BitConverter.ToString(rData));
}
<code end>


###  10.0.1  SusiI2CReadTransfer C#  code
**Description:** This code snippet demonstrates how to perform an I2C read operation using the `SusiI2CReadTransfer` function from the SusiI2C API. This function allows you to read data from an I2C device using either a standard or extended command.

**Parameters:**

- `queryID`: The ID of the I2C bus. This ID should correspond to one of the constants defined in the `SusiI2C` class, such as `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_I2C_OEM0`, etc.
- `addr`: The 7-bit or 10-bit I2C address of the target device. Use the `SUSI_I2C_ENC_7BIT_ADDR` or `SUSI_I2C_ENC_10BIT_ADDR` functions to encode the address appropriately.
- `cmd`: The command byte to send to the device. This parameter is optional and can be set to 0 if no command is required. Use the `SUSI_I2C_ENC_STD_CMD`, `SUSI_I2C_ENC_EXT_CMD`, or `SUSI_I2C_ENC_NO_CMD` functions to encode the command appropriately.
- `rData`: A byte array that will store the data read back from the device.
- `length`: The number of bytes to read into `rData`.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To read 5 bytes of data from an I2C device at address `0x23` using a standard command `0x42`, you would use the following code:

<c# code>
UInt32 Status;
UInt32 addr = SusiI2C.SUSI_I2C_ENC_7BIT_ADDR(0x23); // Encode 7-bit address
UInt32 cmd = SusiI2C.SUSI_I2C_ENC_STD_CMD(0x42); // Encode standard command
UInt32 length = 5;
byte[] rData = new byte[length];
UInt32 queryID = SusiI2C.SUSI_ID_I2C_EXTERNAL;

Status = SusiI2C.SusiI2CReadTransfer(queryID, addr, cmd, rData, length);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Data read from device: " + BitConverter.ToString(rData));
}
else
{
    Console.WriteLine("Failed to perform I2C read operation.");
}
<code end>


###  10.0.1  SusiI2CReadTransfer C#  code
**Description:** This code snippet demonstrates how to perform an I2C write operation using the `SusiI2CWriteTransfer` function from the SusiI2C API. This function allows you to write data to an I2C device using either a standard or extended command.

**Parameters:**

- `queryID`: The ID of the I2C bus. This ID should correspond to one of the constants defined in the `SusiI2C` class, such as `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_I2C_OEM0`, etc.
- `addr`: The 7-bit or 10-bit I2C address of the target device. Use the `SUSI_I2C_ENC_7BIT_ADDR` or `SUSI_I2C_ENC_10BIT_ADDR` functions to encode the address appropriately.
- `cmd`: The command byte to send to the device. This parameter is optional and can be set to 0 if no command is required. Use the `SUSI_I2C_ENC_STD_CMD`, `SUSI_I2C_ENC_EXT_CMD`, or `SUSI_I2C_ENC_NO_CMD` functions to encode the command appropriately.
- `baData`: A byte array containing the data to be written to the device.
- `length`: The number of bytes to write from `baData`.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To write 3 bytes of data to an I2C device at address `0x30` using an extended command `0x1A2B`, you would use the following code:

<c# code>
UInt32 Status;
UInt32 addr = SusiI2C.SUSI_I2C_ENC_7BIT_ADDR(0x30); // Encode 7-bit address
UInt32 cmd = SusiI2C.SUSI_I2C_ENC_EXT_CMD(0x1A2B); // Encode extended command
byte[] baData = new byte[] { 0x0A, 0x0B, 0x0C };
UInt32 length = 3;
UInt32 queryID = SusiI2C.SUSI_ID_I2C_EXTERNAL;

Status = SusiI2C.SusiI2CWriteTransfer(queryID, addr, cmd, baData, length);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to perform I2C write operation.");
}
<code end>

### 10.0.1 SusiFanControlGetConfig C# code

**Description:** This code snippet demonstrates how to retrieve the configuration of a fan controller using the `SusiFanControlGetConfig` function from the `SusiFan` API. It retrieves the current mode (off, full speed, manual PWM, or automatic), the PWM duty cycle for manual mode, and parameters for automatic mode (temperature source, operating mode, temperature limits, and PWM or RPM ranges).

**Parameters:**

- `queryID`: The ID of the fan controller. This ID should correspond to one of the constants defined in the `SusiBoard` class that represents a fan, such as `SUSI_ID_HWM_FAN_CPU`, `SUSI_ID_HWM_FAN_SYSTEM`, etc.
- `config`: A `SusiFanControl` structure that will store the retrieved fan controller configuration.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

<c# code>
UInt32 queryID = SusiBoard.SUSI_ID_HWM_FAN_CPU; // Example: CPU fan

// Get configuration
SusiFanControl config = new SusiFanControl();
UInt32 Status = SusiFan.SusiFanControlGetConfig(queryID, out config);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to get configuration for fan controller.");
}
else
{
    Console.WriteLine("Fan Controller Configuration:");
    Console.WriteLine("  Mode: " + config.Mode);
    Console.WriteLine("  PWM: " + config.PWM);
    // Access other configuration parameters from the 'config' structure
}
<code end>


### 10.0.1 SusiFanControlGetCaps C# code

**Description:** This code snippet demonstrates how to retrieve the capabilities of a fan controller using the `SusiFanControlGetCaps` function from the `SusiFan` API. It retrieves information about the supported control modes, auto mode features, and compatible temperature sources.
** (this function is only used to get capabilities. If you wanna get fanspeed, please use SusiBoardGetValue funtion)
**Parameters:**

- `queryID`: The ID of the fan controller. This ID should correspond to one of the constants defined in the `SusiBoard` class that represents a fan, such as `SUSI_ID_HWM_FAN_CPU`, `SUSI_ID_HWM_FAN_SYSTEM`, etc.
- `ItemId`: The ID of the capability item to retrieve. This can be one of the following:
    - `SusiFan.SUSI_ID_FC_CONTROL_SUPPORT_FLAGS`: Retrieves the control support flags, indicating which control modes are supported (off, full speed, manual PWM, automatic).
    - `SusiFan.SUSI_ID_FC_AUTO_SUPPORT_FLAGS`: Retrieves the auto mode support flags, indicating which auto mode features are supported (low stop, low limit, high limit, PWM control, RPM control).
    - A temperature source ID (e.g., `SusiBoard.SUSI_ID_HWM_TEMP_CPU`): Retrieves the type of the specified temperature source if it is compatible with the fan controller.
- `Value`: A `UInt32` variable that will store the retrieved capability value.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

<c# code>
UInt32 queryID = SusiBoard.SUSI_ID_HWM_FAN_CPU; // Example: CPU fan

// Get control support flags
UInt32 ControlSupportFlags = 0;
UInt32 Status = SusiFan.SusiFanControlGetCaps(queryID, SusiFan.SUSI_ID_FC_CONTROL_SUPPORT_FLAGS, out ControlSupportFlags);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Control Support Flags: " + ControlSupportFlags);
}

// Get auto mode support flags
UInt32 AutoSupportFlags = 0;
Status = SusiFan.SusiFanControlGetCaps(queryID, SusiFan.SUSI_ID_FC_AUTO_SUPPORT_FLAGS, out AutoSupportFlags);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Auto Support Flags: " + AutoSupportFlags);
}

// Check if CPU temperature is a supported source
UInt32 Type = 0;
Status = SusiFan.SusiFanControlGetCaps(queryID, SusiBoard.SUSI_ID_HWM_TEMP_CPU, out Type);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("CPU Temperature Source Type: " + Type);
}
<code end>

**Note:** To get the actual fan speed, use the `SusiBoardGetValue` function with the appropriate fan ID (e.g., `SusiBoard.SUSI_ID_HWM_FAN_CPU`).




###  10.0.1   FanControlSetConfig C# code
**Description:** This code snippet demonstrates how to configure a fan controller using the `SusiFanControlSetConfig` function from the `SusiFan` API. It first initializes a `SusiFanControl` structure with the desired configuration parameters and then calls the `SusiFanControlSetConfig` function to apply the configuration to the specified fan controller.

**Parameters:**

- `queryID`: The ID of the fan controller. This ID should correspond to one of the constants defined in the `SusiBoard` class that represents a fan, such as `SUSI_ID_HWM_FAN_CPU`, `SUSI_ID_HWM_FAN_SYSTEM`, etc.
- `config`: A `SusiFanControl` structure containing the desired configuration parameters for the fan controller.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To set the fan controller associated with `SUSI_ID_HWM_FAN_CPU` to manual mode with a PWM value of 50%, you would use the following code:

<c# code>
// Assuming queryID has been previously defined as SusiBoard.SUSI_ID_HWM_FAN_CPU

SusiFanControl config = new SusiFanControl();
config.Mode = SusiFan.SUSI_FAN_CTRL_MODE_MANUAL; // Set to manual mode
config.PWM = 50; // Set PWM to 50%

UInt32 Status = SusiFan.SusiFanControlSetConfig(queryID, ref config);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to set fan controller configuration.");
}
<code end>

**Note:** The `SusiFanControl` structure allows you to configure various aspects of the fan controller, including the control mode (off, full speed, manual PWM, or automatic), PWM duty cycle for manual mode, and parameters for automatic mode (temperature source, operating mode, temperature limits, and PWM or RPM ranges).




###  10.0.1  SMBUS read operations C#  code
**Description:** This code snippet demonstrates how to perform various SMBus read operations using the `SusiSMB` API. It provides a switch statement that handles different SMBus protocols, allowing you to choose the appropriate read function based on the desired operation.

**Parameters:**

- `queryID`: The ID of the SMBus controller. This ID should correspond to one of the constants defined in the `SusiSMB` class, such as `SUSI_ID_SMBUS_EXTERNAL`, `SUSI_ID_SMBUS_OEM0`, etc.
- `addr`: The 7-bit SMBus slave address to read from.
- `cmd`: The command byte to send to the device before reading data. This parameter is optional and may not be used by all protocols.
- `length`: The number of bytes to read. This parameter is used by block read operations.
- `youroperations`: An enumeration or a variable that represents the desired SMBus protocol to use.

**Return Value:**

- The `result` string will contain the read data or an error message depending on the outcome of the operation.

**SMBus Protocols:**

The code supports the following SMBus protocols:

- `SMB_PROTOCAL_QUICK`: Performs a quick read operation using `SusiSMBReadQuick`. This protocol does not send a command byte and typically reads a single byte of data.
- `SMB_PROTOCAL_BYTE`: Reads a single byte of data using `SusiSMBReceiveByte`.
- `SMB_PROTOCAL_BYTEDATA`: Reads a single byte of data after sending a command byte using `SusiSMBReadByte`.
- `SMB_PROTOCAL_WORDDATA`: Reads two bytes of data (a word) after sending a command byte using `SusiSMBReadWord`.
- `SMB_PROTOCAL_BLOCK`: Reads a block of data using `SusiSMBReadBlock`. The `length` parameter specifies the maximum number of bytes to read.
- `SMB_PROTOCAL_I2CBLOCK`: Reads a block of data using I2C protocol over SMBus using `SusiSMBI2CReadBlock`. The `length` parameter specifies the number of bytes to read.

**Example Usage:**

To read a word (2 bytes) from an SMBus device at address `0x40` using the `SMB_PROTOCAL_WORDDATA` protocol with a command byte of `0x01`, you would use the following code:

<c# code>
// Assuming queryID has been previously defined as SusiSMB.SUSI_ID_SMBUS_EXTERNAL

string result = "";
UInt32 Status;
byte addr = 0x40;
byte cmd = 0x01;
UInt32 length = 0; // Not used for WORDDATA protocol
StringBuilder sb;
byte Data_u8;
byte[] DataBlock;
string youroperations = "SMB_PROTOCAL_WORDDATA"; // Set the desired protocol

switch (youroperations)
{
    // ... other protocol cases ...

    case "SMB_PROTOCAL_WORDDATA":
        UInt16 Data_u16;
        Status = SusiSMB.SusiSMBReadWord(queryID, addr, cmd, out Data_u16);
        if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
            result = string.Format("Read word data failed. (0x{0:X8})", Status);
        else
            result = String.Format("{0:X2} {1:X2}", (byte)Data_u16, (byte)(Data_u16 >> 8));
        break;

    // ... other protocol cases ...
}

Console.WriteLine("Read result: " + result);
<code end>


###  10.0.1  SMBUS write operations C# code
**Description:** This code snippet demonstrates how to perform various SMBus write operations using the `SusiSMB` API. It provides a switch statement that handles different SMBus protocols, allowing you to choose the appropriate write function based on the desired operation.

**Parameters:**

- `queryID`: The ID of the SMBus controller. This ID should correspond to one of the constants defined in the `SusiSMB` class, such as `SUSI_ID_SMBUS_EXTERNAL`, `SUSI_ID_SMBUS_OEM0`, etc.
- `addr`: The 7-bit SMBus slave address to write to.
- `cmd`: The command byte to send to the device before writing data. This parameter is optional and may not be used by all protocols.
- `baData`: A byte array containing the data to be written.
- `length`: The number of bytes to write. This parameter is used by block write operations.
- `youroperations`: An enumeration or a variable that represents the desired SMBus protocol to use.

**Return Value:**

- The `result` string will contain a success message or an error message depending on the outcome of the operation.

**SMBus Protocols:**

The code supports the following SMBus protocols:

- `SMB_PROTOCAL_QUICK`: Performs a quick write operation using `SusiSMBWriteQuick`. This protocol does not send a command byte and typically writes a single byte of data.
- `SMB_PROTOCAL_BYTE`: Writes a single byte of data using `SusiSMBSendByte`.
- `SMB_PROTOCAL_BYTEDATA`: Writes a single byte of data after sending a command byte using `SusiSMBWriteByte`.
- `SMB_PROTOCAL_WORDDATA`: Writes two bytes of data (a word) after sending a command byte using `SusiSMBWriteWord`.
- `SMB_PROTOCAL_BLOCK`: Writes a block of data using `SusiSMBWriteBlock`. The `length` parameter specifies the number of bytes to write.
- `SMB_PROTOCAL_I2CBLOCK`: Writes a block of data using I2C protocol over SMBus using `SusiSMBI2CWriteBlock`. The `length` parameter specifies the number of bytes to write.

**Example Usage:**

To write a word (2 bytes) to an SMBus device at address `0x30` using the `SMB_PROTOCAL_WORDDATA` protocol with a command byte of `0x02` and data `0x1234`, you would use the following code:

<c# code>
// Assuming queryID has been previously defined as SusiSMB.SUSI_ID_SMBUS_EXTERNAL

string result = "";
UInt32 Status;
byte addr = 0x30;
byte cmd = 0x02;
byte[] baData = new byte[] { 0x12, 0x34 }; // Data to write
UInt32 length = 2; // Number of bytes to write
StringBuilder sb;
byte Data_u8;
byte[] DataBlock;
string youroperations = "SMB_PROTOCAL_WORDDATA"; // Set the desired protocol

switch (youroperations)
{
    // ... other protocol cases ...

    case "SMB_PROTOCAL_WORDDATA":
        UInt16 Data_u16 = (UInt16)(baData[0] + (baData[1] << 8));
        Status = SusiSMB.SusiSMBWriteWord(queryID, addr, cmd, Data_u16);
        if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
            result = string.Format("Write word data failed. (0x{0:X8})", Status);
        else
            result = "Write word data successful.";
        break;

    // ... other protocol cases ...
}

Console.WriteLine("Write result: " + result);
<code end>


###  10.0.1  StorageGetCaps C# code
**Description:** This code snippet demonstrates how to initialize and retrieve the capabilities of storage devices using the `SusiStorage` API. It iterates through all available storage devices and retrieves their total size, block size, and maximum password length.

**Parameters:**

- `queryID`: The ID of the storage device. This ID should correspond to one of the constants defined in the `SusiStorage` class, such as `SUSI_ID_STORAGE_STD`, `SUSI_ID_STORAGE_OEM0`, etc.
- `info`: A `DeviceInfo` structure that will store the retrieved storage device capabilities.

**Return Value:**

- None. The function updates the `info` structure with the retrieved capabilities.

**Example Usage:**

<c# code>
// Define a custom structure to store storage device information
public struct DeviceInfo
{
    public UInt32 ID;
    public UInt32 TotalSize;
    public UInt32 BlockSize;
    public UInt32 MaxKeySize;

    public DeviceInfo(UInt32 id)
    {
        ID = id;
        TotalSize = 0;
        BlockSize = 0;
        MaxKeySize = 0;
    }
}

private void InitializeStorage()
{
    UInt32 Status;

    for (UInt32 i = 0; i < SusiStorage.SUSI_ID_STORAGE_MAX; i++)
    {
        UInt32 queryID = SusiStorage.SUSI_ID_STORAGE_STD + i;
        DeviceInfo info = new DeviceInfo(i);

        Status = SusiStorage.SusiStorageGetCaps(queryID, SusiStorage.SUSI_ID_STORAGE_TOTAL_SIZE, out info.TotalSize);
        if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to get total size for storage device " + i);
            continue;
        }

        Status = SusiStorage.SusiStorageGetCaps(queryID, SusiStorage.SUSI_ID_STORAGE_BLOCK_SIZE, out info.BlockSize);
        if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to get block size for storage device " + i);
            info.BlockSize = 0;
        }

        Status = SusiStorage.SusiStorageGetCaps(queryID, SusiStorage.SUSI_ID_STORAGE_PSW_MAX_LEN, out info.MaxKeySize);
        if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to get maximum password length for storage device " + i);
            info.MaxKeySize = 0;
        }

        Console.WriteLine("Storage Device " + i + ":");
        Console.WriteLine("  Total Size: " + info.TotalSize + " bytes");
        Console.WriteLine("  Block Size: " + info.BlockSize + " bytes");
        Console.WriteLine("  Maximum Password Length: " + info.MaxKeySize + " characters");
    }
}
<code end>


###  10.0.1  StorageAreaWrite C# code
**Description:** This code snippet demonstrates how to write data to a specific area of a storage device using the `SusiStorageAreaWrite` function from the `SusiStorage` API. 

**Parameters:**

- `queryID`: The ID of the storage device. This ID should correspond to one of the constants defined in the `SusiStorage` class, such as `SUSI_ID_STORAGE_STD`, `SUSI_ID_STORAGE_OEM0`, etc.
- `offset`: The offset within the storage device where data should be written, in bytes.
- `baData`: A byte array containing the data to be written.
- `(UInt32)baData.Length`: The number of bytes to write from the `baData` array.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To write 16 bytes of data starting from offset `0x1000` to a storage device associated with `SUSI_ID_STORAGE_STD`, you would use the following code:

<c# code>
// Assuming queryID has been previously defined as SusiStorage.SUSI_ID_STORAGE_STD

UInt32 Status;
UInt32 offset = 0x1000; // Offset in bytes
byte[] baData = new byte[16] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10 }; // Data to write

Status = SusiStorage.SusiStorageAreaWrite(queryID, offset, baData, (UInt32)baData.Length);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to write data to storage area.");
}
<code end>

**Note:** Ensure that the specified offset and length are within the bounds of the storage device's addressable space.


###  10.0.1   StorageAreaWrite C#  code
**Description:** This code snippet demonstrates how to read data from a specific area of a storage device using the `SusiStorageAreaRead` function from the `SusiStorage` API. 

**Parameters:**

- `queryID`: The ID of the storage device. This ID should correspond to one of the constants defined in the `SusiStorage` class, such as `SUSI_ID_STORAGE_STD`, `SUSI_ID_STORAGE_OEM0`, etc.
- `offset`: The offset within the storage device from where data should be read, in bytes.
- `data`: A byte array that will store the read data.
- `(UInt32)data.Length`: The number of bytes to read into the `data` array.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To read 16 bytes of data starting from offset `0x2000` from a storage device associated with `SUSI_ID_STORAGE_OEM0`, you would use the following code:

<c# code>
// Assuming queryID has been previously defined as SusiStorage.SUSI_ID_STORAGE_OEM0

UInt32 Status;
UInt32 offset = 0x2000; // Offset in bytes
byte[] data = new byte[16];

Status = SusiStorage.SusiStorageAreaRead(queryID, offset, data, (UInt32)data.Length);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to read data from storage area.");
}
else
{
    Console.WriteLine("Data read from storage area: " + BitConverter.ToString(data));
}
<code end>

**Note:** Ensure that the specified offset and length are within the bounds of the storage device's addressable space.


###  10.0.1  StorageAreaSetLock C# code
**Description:** This code snippet demonstrates how to lock a specific area of a storage device using the `SusiStorageAreaSetLock` function from the `SusiStorage` API. 

**Parameters:**

- `queryID`: The ID of the storage device. This ID should correspond to one of the constants defined in the `SusiStorage` class, such as `SUSI_ID_STORAGE_STD`, `SUSI_ID_STORAGE_OEM0`, etc.
- `data`: A byte array containing the password to lock the storage area.
- `(UInt32)data.Length`: The length of the password in bytes.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To lock a storage area using the password "secret", you would use the following code:

<c# code>
// Assuming queryID has been previously defined

UInt32 Status;
string PasswordText = "secret";
ASCIIEncoding encoding = new System.Text.ASCIIEncoding();
byte[] data = encoding.GetBytes(PasswordText);

Status = SusiStorage.SusiStorageAreaSetLock(queryID, data, (UInt32)data.Length);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to lock storage area.");
}
<code end>

**Note:** The specific area to be locked may need to be configured separately using other functions from the `SusiStorage` API.


###  10.0.1  StorageAreaSetUnlock C#  code
**Description:** This code snippet demonstrates how to unlock a specific area of a storage device using the `SusiStorageAreaSetUnlock` function from the `SusiStorage` API. 

**Parameters:**

- `Dev.ID`: The ID of the storage device. This ID should correspond to one of the constants defined in the `SusiStorage` class, such as `SUSI_ID_STORAGE_STD`, `SUSI_ID_STORAGE_OEM0`, etc.
- `data`: A byte array containing the password to unlock the storage area.
- `(UInt32)data.Length`: The length of the password in bytes.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

To unlock a storage area using the password "password123", you would use the following code:

<c# code>
// Assuming Dev.ID has been previously defined

UInt32 Status;
string PasswordText = "password123";
ASCIIEncoding encoding = new System.Text.ASCIIEncoding();
byte[] data = encoding.GetBytes(PasswordText);

Status = SusiStorage.SusiStorageAreaSetUnlock(Dev.ID, data, (UInt32)data.Length);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to unlock storage area.");
}
<code end>

**Note:** The specific area to be unlocked should have been previously locked using the `SusiStorageAreaSetLock` function with the same password.



###  10.0.1  ThermalProtectionGetConfig C# code
**Description:** This code snippet demonstrates how to initialize and retrieve the capabilities of thermal protection devices using the `SusiThermalProtection` API. It iterates through all available thermal protection devices, retrieves their configuration, and then queries their capabilities, including supported events, trigger and clear temperature thresholds, and associated temperature sources.

**Parameters:**

- `queryID`: The ID of the thermal protection device. This ID should correspond to one of the constants defined in the `SusiThermalProtection` class, such as `SUSI_ID_THERMAL_PROTECT_1`, `SUSI_ID_THERMAL_PROTECT_2`, etc.
- `config`: A `SusiThermalProtect` structure that will store the retrieved thermal protection configuration.
- `SupportFlags`: A `UInt32` variable that will store the supported event flags.
- `TriggerMaximum`: A `UInt32` variable that will store the maximum trigger temperature in 0.1 Kelvins.
- `TriggerMinimum`: A `UInt32` variable that will store the minimum trigger temperature in 0.1 Kelvins.
- `ClearMaximum`: A `UInt32` variable that will store the maximum clear temperature in 0.1 Kelvins.
- `ClearMinimum`: A `UInt32` variable that will store the minimum clear temperature in 0.1 Kelvins.
- `Source`: A `UInt32` variable that will store the ID of the associated temperature source.

**Return Value:**

- None. The function updates the variables with the retrieved capabilities.

**Example Usage:**

<c# code>
private void InitializeThermal()
{
    UInt32 Status;

    for (UInt32 i = 0; i < SusiThermalProtection.SUSI_ID_THERMAL_MAX; i++)
    {
        UInt32 queryID = SusiThermalProtection.SUSI_ID_THERMAL_PROTECT_1 + i;
        SusiThermalProtect config = new SusiThermalProtect();

        Status = SusiThermalProtection.SusiThermalProtectionGetConfig(queryID, out config);
        if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to get configuration for thermal protection device " + i);
            continue;
        }

        UInt32 SupportFlags = 0;
        UInt32 TriggerMaximum = 0;
        UInt32 TriggerMinimum = 0;
        UInt32 ClearMaximum = 0;
        UInt32 ClearMinimum = 0;

        SusiThermalProtection.SusiThermalProtectionGetCaps(queryID, SusiThermalProtection.SUSI_ID_TP_EVENT_SUPPORT_FLAGS, out SupportFlags);
        SusiThermalProtection.SusiThermalProtectionGetCaps(queryID, SusiThermalProtection.SUSI_ID_TP_EVENT_TRIGGER_MAXIMUM, out TriggerMaximum);
        SusiThermalProtection.SusiThermalProtectionGetCaps(queryID, SusiThermalProtection.SUSI_ID_TP_EVENT_TRIGGER_MINIMUM, out TriggerMinimum);
        SusiThermalProtection.SusiThermalProtectionGetCaps(queryID, SusiThermalProtection.SUSI_ID_TP_EVENT_CLEAR_MAXIMUM, out ClearMaximum);
        SusiThermalProtection.SusiThermalProtectionGetCaps(queryID, SusiThermalProtection.SUSI_ID_TP_EVENT_CLEAR_MINIMUM, out ClearMinimum);

        Console.WriteLine("Thermal Protection Device " + i + ":");
        Console.WriteLine("  Supported Events: " + SupportFlags);
        Console.WriteLine("  Trigger Temperature Range: " + SusiBoard.SusiDecodeCelcius(TriggerMinimum) + "Â°C - " + SusiBoard.SusiDecodeCelcius(TriggerMaximum) + "Â°C");
        Console.WriteLine("  Clear Temperature Range: " + SusiBoard.SusiDecodeCelcius(ClearMinimum) + "Â°C - " + SusiBoard.SusiDecodeCelcius(ClearMaximum) + "Â°C");

        for (UInt32 j = 0; j < SusiBoard.SUSI_ID_HWM_TEMP_MAX; j++)
        {
            UInt32 Source = 0;
            Status = SusiThermalProtection.SusiThermalProtectionGetCaps(queryID, (SusiBoard.SUSI_ID_HWM_TEMP_CPU + j), out Source);
            if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
            {
                Console.WriteLine("    Associated Temperature Source: " + (SusiBoard.SUSI_ID_HWM_TEMP_CPU + j));
            }
        }
    }
}
<code end>

**Note:** The `SusiBoard.SusiDecodeCelcius` function is used to convert the temperature values from 0.1 Kelvins to Celsius.


###  10.0.1  ThermalProtectionGetConfig C# code
**Description:** This code snippet demonstrates how to retrieve the configuration of a thermal protection device using the `SusiThermalProtectionGetConfig` function from the `SusiThermalProtection` API.

**Parameters:**

- `queryID`: The ID of the thermal protection device. This ID should correspond to one of the constants defined in the `SusiThermalProtection` class, such as `SUSI_ID_THERMAL_PROTECT_1`, `SUSI_ID_THERMAL_PROTECT_2`, etc.
- `Dev.Config`: A `SusiThermalProtect` structure that will store the retrieved thermal protection configuration.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

<c# code>
// Assuming queryID and Dev.Config have been previously defined

UInt32 Status;

Status = SusiThermalProtection.SusiThermalProtectionGetConfig(queryID, out Dev.Config);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to get thermal protection configuration.");
}
else
{
    Console.WriteLine("Thermal Protection Configuration:");
    Console.WriteLine("  Source ID: " + Dev.Config.SourceId);
    Console.WriteLine("  Event Type: " + Dev.Config.EventType);
    Console.WriteLine("  Send Event Temperature: " + SusiBoard.SusiDecodeCelcius(Dev.Config.SendEventTemperature) + "Â°C");
    Console.WriteLine("  Clear Event Temperature: " + SusiBoard.SusiDecodeCelcius(Dev.Config.ClearEventTemperature) + "Â°C");
}
<code end>

**Note:** The `SusiBoard.SusiDecodeCelcius` function is used to convert the temperature values from 0.1 Kelvins to Celsius.


###  10.0.1  VgaGetCaps VgaGetBacklightLevel VgaGetBacklightEnable C#  code
**Description:** This code snippet demonstrates how to initialize and retrieve the capabilities of VGA (Video Graphics Array) devices, specifically focusing on backlight control, using the `SusiVga` API. It iterates through all available backlight devices, retrieves their maximum and minimum brightness levels, checks for ACPI and WMI support, and retrieves the current backlight level or enable status.

**Parameters:**

- `i`: The ID of the backlight device. This ID should be within the range of `0` to `SusiVga.SUSI_ID_BACKLIGHT_MAX - 1`.
- `MaxValue`: A `UInt32` variable that will store the maximum brightness level.
- `MinValue`: A `UInt32` variable that will store the minimum brightness level.
- `Value`: A `UInt32` variable that will store the current backlight level or enable status.
- `SupportACPI`: A boolean variable that indicates whether ACPI backlight control is supported.
- `SupportWMI`: A boolean variable that indicates whether WMI backlight control is supported.

**Return Value:**

- None. The function updates the variables with the retrieved capabilities.

**Example Usage:**

<c# code>
private void InitializeVGA()
{
    UInt32 Status;

    for (UInt32 i = 0; i < SusiVga.SUSI_ID_BACKLIGHT_MAX; i++)
    {
        UInt32 MaxValue = 0;
        UInt32 MinValue = 0;
        UInt32 Value = 0;
        bool SupportACPI = false;
        bool SupportWMI = false;

        Status = SusiVga.SusiVgaGetCaps(i, SusiVga.SUSI_ID_VGA_BRIGHTNESS_MAXIMUM, out MaxValue);
        if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
        {
            SusiVga.SusiVgaGetCaps(i, SusiVga.SUSI_ID_VGA_BRIGHTNESS_MINIMUM, out MinValue);
        }
        else
        {
            Console.WriteLine("Failed to get brightness capabilities for backlight device " + i);
            continue;
        }

        Status = SusiVga.SusiVgaGetBacklightLevel(i, out Value);
        if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
        {
            SupportACPI = true;
        }
        else
        {
            if (MaxValue == 0)
            {
                Status = SusiVga.SusiVgaGetBacklightEnable(i, out Value);
                if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
                {
                    Console.WriteLine("Failed to get backlight enable status for backlight device " + i);
                    continue;
                }
            }
        }

        Console.WriteLine("Backlight Device " + i + ":");
        Console.WriteLine("  Brightness Range: " + MinValue + " - " + MaxValue);
        Console.WriteLine("  ACPI Support: " + SupportACPI);
        Console.WriteLine("  WMI Support: " + SupportWMI);

        if (SupportACPI)
        {
            Console.WriteLine("  Current Backlight Level: " + Value);
        }
        else if (MaxValue == 0)
        {
            Console.WriteLine("  Backlight Enabled: " + (Value == SusiVga.SUSI_BACKLIGHT_SET_ON));
        }
    }
}
<code end>

**Note:** The code checks for ACPI support by attempting to retrieve the backlight level using `SusiVgaGetBacklightLevel`. If this function fails and the maximum brightness level is 0, it then attempts to retrieve the backlight enable status using `SusiVgaGetBacklightEnable`.


###  10.0.1  VgaSetFrequency VgaGetFrequency C# code
**Description:** This code snippet demonstrates how to set and get the frequency of a VGA (Video Graphics Array) device using the `SusiVga` API. It first attempts to set the frequency using `SusiVgaSetFrequency` and then retrieves the current frequency using `SusiVgaGetFrequency`.

**Parameters:**

- `queryID`: The ID of the VGA device. This ID should be within the range of `0` to `SusiVga.SUSI_ID_BACKLIGHT_MAX - 1`.
- `DevqueryIDID`: The ID of the VGA device. This ID should be within the range of `0` to `SusiVga.SUSI_ID_BACKLIGHT_MAX - 1`.
- `Value`: A `UInt32` variable that represents the desired frequency to set and will store the retrieved frequency value.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

<c# code>
// Assuming queryID has been previously defined

UInt32 Status;
UInt32 Value = 60; // Desired frequency in Hz

Status = SusiVga.SusiVgaSetFrequency(queryID, Value);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to set VGA frequency.");
}

Status = SusiVga.SusiVgaGetFrequency(queryID, out Value);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Current VGA frequency: " + Value + " Hz");
}
else
{
    Console.WriteLine("Failed to get VGA frequency.");
}
<code end>

**Note:** The supported frequency range and units may vary depending on the specific VGA device.


###  10.0.1  VgaSetPolarity VgaGetPolarity C# code
**Description:** This code snippet demonstrates how to set and get the polarity of a VGA (Video Graphics Array) backlight using the `SusiVga` API. It first attempts to set the polarity using `SusiVgaSetPolarity` and then retrieves the current polarity using `SusiVgaGetPolarity`.

**Parameters:**

- `queryID`: The ID of the VGA backlight device. This ID should be within the range of `0` to `SusiVga.SUSI_ID_BACKLIGHT_MAX - 1`.
- `Value`: A `UInt32` variable that will store the retrieved polarity value.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Polarity Values:**

- `SusiVga.SUSI_BACKLIGHT_POLARITY_ON`: Indicates that the backlight is active high.
- `SusiVga.SUSI_BACKLIGHT_POLARITY_OFF`: Indicates that the backlight is active low.

**Example Usage:**

<c# code>
// Assuming queryID has been previously defined

UInt32 Status;
UInt32 Value;

// Set the backlight polarity to active high
Status = SusiVga.SusiVgaSetPolarity(queryID, SusiVga.SUSI_BACKLIGHT_POLARITY_ON);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to set backlight polarity.");
}

// Get the current backlight polarity
Status = SusiVga.SusiVgaGetPolarity(queryID, out Value);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    if (Value == SusiVga.SUSI_BACKLIGHT_POLARITY_OFF)
    {
        Console.WriteLine("Backlight polarity is active low.");
    }
    else
    {
        Console.WriteLine("Backlight polarity is active high.");
    }
}
else
{
    Console.WriteLine("Failed to get backlight polarity.");
}
<code end>

**Note:** The backlight polarity determines whether a high or low logic level activates the backlight.


###  10.0.1  VgaSetBacklightEnable VgaGetBacklightEnable C#  code
**Description:** This code snippet demonstrates how to enable and disable a VGA (Video Graphics Array) backlight using the `SusiVga` API. It first attempts to disable the backlight using `SusiVgaSetBacklightEnable` and then retrieves the current backlight enable status using `SusiVgaGetBacklightEnable`.

**Parameters:**

- `queryID`: The ID of the VGA backlight device. This ID should be within the range of `0` to `SusiVga.SUSI_ID_BACKLIGHT_MAX - 1`.
- `Value`: A `UInt32` variable that will store the retrieved backlight enable status.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Enable Status Values:**

- `SusiVga.SUSI_BACKLIGHT_SET_OFF`: Indicates that the backlight is disabled.
- `SusiVga.SUSI_BACKLIGHT_SET_ON`: Indicates that the backlight is enabled.

**Example Usage:**

<c# code>
// Assuming queryID has been previously defined

UInt32 Status;
UInt32 Value;

// Disable the backlight
Status = SusiVga.SusiVgaSetBacklightEnable(queryID, SusiVga.SUSI_BACKLIGHT_SET_OFF);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to disable backlight.");
}

// Get the current backlight enable status
Status = SusiVga.SusiVgaGetBacklightEnable(queryID, out Value);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    if (Value == SusiVga.SUSI_BACKLIGHT_SET_OFF)
    {
        Console.WriteLine("Backlight is disabled.");
    }
    else
    {
        Console.WriteLine("Backlight is enabled.");
    }
}
else
{
    Console.WriteLine("Failed to get backlight enable status.");
}
<code end>

**Note:** Enabling or disabling the backlight controls whether the display is illuminated.


###  10.0.1  VgaGetBacklightBrightness VgaGetBacklightLevel C#  code
**Description:** This code snippet demonstrates how to retrieve the brightness of a VGA (Video Graphics Array) backlight using two different functions from the `SusiVga` API: `SusiVgaGetBacklightBrightness` and `SusiVgaGetBacklightLevel`.

**Parameters:**

- `queryID`: The ID of the VGA backlight device. This ID should be within the range of `0` to `SusiVga.SUSI_ID_BACKLIGHT_MAX - 1`.
- `Value`: A `UInt32` variable that will store the retrieved brightness value.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Brightness Representation:**

- `SusiVgaGetBacklightBrightness`: Retrieves the brightness as a percentage value (0-100).
- `SusiVgaGetBacklightLevel`: Retrieves the brightness as a discrete level within a predefined range (e.g., 0-9).

**Example Usage:**

<c# code>
// Assuming queryID has been previously defined

UInt32 Status;
UInt32 Value;

// Get the backlight brightness as a percentage
Status = SusiVga.SusiVgaGetBacklightBrightness(queryID, out Value);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Backlight brightness (percentage): " + Value + "%");
}
else
{
    Console.WriteLine("Failed to get backlight brightness (percentage).");
}

// Get the backlight brightness as a level
Status = SusiVga.SusiVgaGetBacklightLevel(queryID, out Value);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Backlight brightness (level): " + Value);
}
else
{
    Console.WriteLine("Failed to get backlight brightness (level).");
}
<code end>

**Note:** The availability and meaning of the brightness values may vary depending on the specific VGA device and its driver.


###  10.0.1  VgaSetBacklightBrightness VgaSetBacklightLevel C#  code
**Description:** This code snippet demonstrates how to set the brightness of a VGA (Video Graphics Array) backlight using two different functions from the `SusiVga` API: `SusiVgaSetBacklightBrightness` and `SusiVgaSetBacklightLevel`.

**Parameters:**

- `queryID`: The ID of the VGA backlight device. This ID should be within the range of `0` to `SusiVga.SUSI_ID_BACKLIGHT_MAX - 1`.
- `Value`: A `UInt32` variable that represents the desired brightness percentage (0-100) to set using `SusiVgaSetBacklightBrightness`.
- `BLValue`: A `UInt32` variable that represents the desired brightness level to set using `SusiVgaSetBacklightLevel`.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Brightness Representation:**

- `SusiVgaSetBacklightBrightness`: Sets the brightness as a percentage value (0-100).
- `SusiVgaSetBacklightLevel`: Sets the brightness as a discrete level within a predefined range (e.g., 0-9).

**Example Usage:**

<c# code>
// Assuming queryID has been previously defined

UInt32 Status;
UInt32 Value = 75; // Desired brightness percentage
UInt32 BLValue = 5; // Desired brightness level

// Set the backlight brightness to 75%
Status = SusiVga.SusiVgaSetBacklightBrightness(queryID, Value);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Backlight brightness set to 75%.");
}
else
{
    Console.WriteLine("Failed to set backlight brightness to 75%.");
}

// Set the backlight brightness to level 5
Status = SusiVga.SusiVgaSetBacklightLevel(queryID, BLValue);
if (Status == SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Backlight brightness set to level 5.");
}
else
{
    Console.WriteLine("Failed to set backlight brightness to level 5.");
}
<code end>

**Note:** The availability and range of brightness values may vary depending on the specific VGA device and its driver.


###  10.0.1  WDogGetCaps C#  code
**Description:** This code snippet demonstrates how to initialize and retrieve the capabilities of watchdog timer (WDT) devices using the `SusiWDog` API. It iterates through all available watchdog timers and retrieves their supported event types, maximum and minimum delay, reset, and event times, as well as the minimum time unit.

**Parameters:**

- `i`: The ID of the watchdog timer device. This ID should be within the range of `0` to `SusiWDog.SUSI_ID_WATCHDOG_MAX - 1`.
- `SupportEventFlags`: A `UInt32` variable that will store the supported event type flags.
- `MaxDelay`: A `UInt32` variable that will store the maximum delay time.
- `MinDelay`: A `UInt32` variable that will store the minimum delay time.
- `MaxReset`: A `UInt32` variable that will store the maximum reset time.
- `MinReset`: A `UInt32` variable that will store the minimum reset time.
- `MaxEvent`: A `UInt32` variable that will store the maximum event time.
- `MinEvent`: A `UInt32` variable that will store the minimum event time.
- `Unit`: A `UInt32` variable that will store the minimum time unit.

**Return Value:**

- None. The function updates the variables with the retrieved capabilities.

**Example Usage:**

<c# code>
private void InitializeWDog()
{
    UInt32 Status;

    for (UInt32 i = 0; i < SusiWDog.SUSI_ID_WATCHDOG_MAX; i++)
    {
        UInt32 SupportEventFlags = 0;
        UInt32 MaxDelay = 0;
        UInt32 MinDelay = 0;
        UInt32 MaxReset = 0;
        UInt32 MinReset = 0;
        UInt32 MaxEvent = 0;
        UInt32 MinEvent = 0;
        UInt32 Unit = 0;

        Status = SusiWDog.SusiWDogGetCaps(i, SusiWDog.SUSI_ID_WDT_SUPPORT_FLAGS, out SupportEventFlags);
        if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to get capabilities for watchdog timer " + i);
            continue;
        }

        SusiWDog.SusiWDogGetCaps(i, SusiWDog.SUSI_ID_WDT_DELAY_MAXIMUM, out MaxDelay);
        SusiWDog.SusiWDogGetCaps(i, SusiWDog.SUSI_ID_WDT_DELAY_MINIMUM, out MinDelay);
        SusiWDog.SusiWDogGetCaps(i, SusiWDog.SUSI_ID_WDT_RESET_MAXIMUM, out MaxReset);
        SusiWDog.SusiWDogGetCaps(i, SusiWDog.SUSI_ID_WDT_RESET_MINIMUM, out MinReset);
        SusiWDog.SusiWDogGetCaps(i, SusiWDog.SUSI_ID_WDT_EVENT_MAXIMUM, out MaxEvent);
        SusiWDog.SusiWDogGetCaps(i, SusiWDog.SUSI_ID_WDT_EVENT_MINIMUM, out MinEvent);
        SusiWDog.SusiWDogGetCaps(i, SusiWDog.SUSI_ID_WDT_UNIT_MINIMUM, out Unit);

        Console.WriteLine("Watchdog Timer " + i + ":");
        Console.WriteLine("  Supported Events: " + SupportEventFlags);
        Console.WriteLine("  Delay Time Range: " + MinDelay + " - " + MaxDelay + " (" + Unit + " units)");
        Console.WriteLine("  Reset Time Range: " + MinReset + " - " + MaxReset + " (" + Unit + " units)");
        Console.WriteLine("  Event Time Range: " + MinEvent + " - " + MaxEvent + " (" + Unit + " units)");
    }
}
<code end>

**Note:** The time units may vary depending on the specific watchdog timer device.





### 10.0.1  WDogSetCallBack C# code
**Description:** This code snippet demonstrates how to set a callback function for a watchdog timer (WDT) using the `SusiWDog` API. It first defines a static callback function `fn_callback` and an instance method `IntCallback` that will be invoked when the watchdog timer triggers an interrupt. Then, it registers the callback function using `SusiWDogSetCallBack`.

**Parameters:**

- `queryID`: The ID of the watchdog timer device. This ID should be within the range of `0` to `SusiWDog.SUSI_ID_WATCHDOG_MAX - 1`.
- `fn_callback`: A static delegate of type `SusiWDog.SUSI_WDT_INT_CALLBACK` that represents the callback function.
- `IntCallback`: An instance method that will be invoked when the watchdog timer triggers an interrupt.
- `context`: An `IntPtr` that represents the context passed to the callback function. In this example, it is set to `IntPtr.Zero`.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

<c# code>
// Assuming queryID has been previously defined

static SusiWDog.SUSI_WDT_INT_CALLBACK fn_callback;

private void IntCallback(IntPtr context)
{
    Console.WriteLine("Watchdog timer interrupt triggered!");
    // Perform your desired action here
}

// Set the callback function
fn_callback = new SusiWDog.SUSI_WDT_INT_CALLBACK(IntCallback);
IntPtr ptr = Marshal.GetFunctionPointerForDelegate(fn_callback);
SusiWDog.SusiWDogSetCallBack(queryID, ptr, IntPtr.Zero);
<code end>

**Note:** The callback function `IntCallback` will be invoked in a separate thread when the watchdog timer triggers an interrupt.


###  10.0.1  WDogStart and WDogStop C# code
**Description:** This code snippet demonstrates how to start and stop a watchdog timer (WDT) using the `SusiWDog` API. It first sets the desired delay, event, and reset times, as well as the event type. Then, it starts the watchdog timer using `SusiWDogStart`. Finally, it stops the watchdog timer using `SusiWDogStop`.

**Parameters:**

- `queryID`: The ID of the watchdog timer device. This ID should be within the range of `0` to `SusiWDog.SUSI_ID_WATCHDOG_MAX - 1`.
- `m_DelayTime`: The delay time in the units specified by the watchdog timer's capabilities.
- `m_EventTime`: The event time in the units specified by the watchdog timer's capabilities.
- `m_ResetTime`: The reset time in the units specified by the watchdog timer's capabilities.
- `m_EventType`: The event type, which can be one of the following:
    - `SusiWDog.SUSI_WDT_EVENT_TYPE_NONE`: No event.
    - `SusiWDog.SUSI_WDT_EVENT_TYPE_IRQ`: Generate an interrupt.
    - `SusiWDog.SUSI_WDT_EVENT_TYPE_SCI`: Generate a system control interrupt.
    - `SusiWDog.SUSI_WDT_EVENT_TYPE_PWRCYCLE`: Perform a power cycle.
    - `SusiWDog.SUSI_WDT_EVENT_TYPE_PIN`: Toggle a GPIO pin.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred. Refer to the `SusiStatus` enumeration for the specific error code.

**Example Usage:**

<c# code>
// Assuming queryID has been previously defined

UInt32 Status;
UInt32 m_DelayTime = 10; // Delay time in seconds (assuming time unit is seconds)
UInt32 m_EventTime = 5; // Event time in seconds
UInt32 m_ResetTime = 15; // Reset time in seconds
UInt32 m_EventType = SusiWDog.SUSI_WDT_EVENT_TYPE_IRQ; // Generate an interrupt

// Start the watchdog timer
Status = SusiWDog.SusiWDogStart(queryID, m_DelayTime, m_EventTime, m_ResetTime, m_EventType);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to start watchdog timer.");
}

// Stop the watchdog timer
Status = SusiWDog.SusiWDogStop(queryID);
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to stop watchdog timer.");
}
<code end>

**Note:** The time units for `m_DelayTime`, `m_EventTime`, and `m_ResetTime` should match the units specified by the watchdog timer's capabilities. Starting the watchdog timer initiates its countdown, and if the countdown reaches zero without being reset, the specified event will be triggered. Stopping the watchdog timer disables it and prevents it from triggering any events.


### 10.0.1  SusiLibInitialize and SusiLibUninitialize C# code
**Description:** This code snippet demonstrates how to initialize and uninitialize the Susi library using the `SusiLibInitialize` and `SusiLibUninitialize` functions from the `SusiLib` class(defined in susi4.cs). 

**SusiLibInitialize:**

The `SusiLibInitialize` function initializes the Susi library and loads the necessary drivers. It must be called before any other Susi API functions can be used.

**Parameters:**

- None.

**Return Value:**

- `SusiStatus.SUSI_STATUS_SUCCESS`: The function call was successful.
- Other `SusiStatus` values: An error occurred during initialization. Refer to the `SusiStatus` enumeration for the specific error code.

**SusiLibUninitialize:**

The `SusiLibUninitialize` function uninitializes the Susi library and releases any resources held by the library. It should be called when you are finished using the Susi API.

**Parameters:**

- None.

**Return Value:**

- None.

**Example Usage:**

<c# code>
// Initialize the Susi library
UInt32 Status = SusiLib.SusiLibInitialize();
if (Status != SusiStatus.SUSI_STATUS_SUCCESS)
{
    Console.WriteLine("Failed to initialize Susi library.");
    return;
}

// ... Your Susi API calls ...

// Uninitialize the Susi library
SusiLib.SusiLibUninitialize();
<code end>

**Note:** It is important to call `SusiLibUninitialize` when you are finished using the Susi API to ensure that all resources are properly released. Failure to do so may result in memory leaks or other issues.



### 12.1.1 python code SusiLibInitialize python code 

<python code>
import ctypes
dll = ctypes.CDLL('./Susi4.dll')

dll.SusiLibInitialize.restype = ctypes.c_uint32
status = dll.SusiLibInitialize()
if status != 0:
    print(f"SusiLibInitialize failed with error code: {hex(status)}")
    exit()

# do your action between SusiLibInitialize and SusiLibUninitialize.

dll.SusiLibUninitialize.restype = ctypes.c_uint32
status = dll.SusiLibUninitialize()
if status != 0:
    print(f"SusiLibUninitialize failed with error code: {hex(status)}")
	exit()
<code end>


### 12.1.1 python code SusiBoardGetValue SusiBoardSetValue python code 
*Use this function To know SMBUS support or not. To know I2C support or not. 
*Use this function to get fanspeed,such as ID:SUSI_ID_HWM_TEMP_CPU, SUSI_ID_HWM_FAN_CPU ,etc. (replace your desired id)
<python code>
import ctypes

dll = ctypes.CDLL('./Susi4.dll')

dll.SusiBoardGetValue.restype = ctypes.c_uint
dll.SusiBoardGetValue.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint)]

id_value = ctypes.c_uint(SUSI_ID_HWM_FAN_CPU)  # Get cpu fan speed.
value = ctypes.c_uint()
status = dll.SusiBoardGetValue(id_value, ctypes.byref(value))
if status == 0:
    print(f"speed: {value.value} ")
else:
    print(f"Failed to get fan speed, error code: {hex(status)}")


dll.SusiBoardSetValue.restype = ctypes.c_uint
dll.SusiBoardSetValue.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint)]

id_value = ctypes.c_uint(SUSI_ID_BOARD_BUZZER_ONOFF_VAL)  # Control buzzer on/off
value = ctypes.c_uint(1)  # Turn on the buzzer
status = dll.SusiBoardSetValue(id_value, ctypes.byref(value))
if status == 0:
    print("Buzzer turned on")
else:
    print(f"Failed to turn on buzzer, error code: {hex(status)}")

<code end>


**Notes:**

* Replace `SUSI_ID_HWM_FAN_CPU` and `SUSI_ID_BOARD_BUZZER_ONOFF_VAL` with the actual IDs you want to use.
* Modify the code as needed to fit your application.




### 12.1.1 python code SusiBoardGetStringA python code 

<python code>
import ctypes

dll = ctypes.CDLL('./Susi4.dll')

dll.SusiBoardGetStringA.restype = ctypes.c_uint
dll.SusiBoardGetStringA.argtypes = [ctypes.c_uint, ctypes.c_char_p, ctypes.POINTER(ctypes.c_uint)]

id_value = ctypes.c_uint(SUSI_ID_MAPPING_GET_NAME_INFO(SUSI_ID_BOARD_MANUFACTURER_STR))  # Get motherboard manufacturer name
buffer_size = ctypes.c_uint(256)
buffer = ctypes.create_string_buffer(buffer_size.value)
status = dll.SusiBoardGetStringA(id_value, buffer, ctypes.byref(buffer_size))
if status == 0:
    print(f"Motherboard manufacturer: {buffer.value.decode('utf-8')}")
else:
    print(f"Failed to get motherboard manufacturer name, error code: {hex(status)}")

<code end>


**Notes:**

* Replace  `SUSI_ID_MAPPING_GET_NAME_INFO(SUSI_ID_BOARD_MANUFACTURER_STR)` with the actual IDs you want to use.
* Modify the code as needed to fit your application.
* `SusiBoardGetStringA` requires a pre-allocated buffer to store the string, so we use `ctypes.create_string_buffer` to create a buffer and pass its address and size.







### 12.1.1 python code SusiSMBReadByte SusiSMBWriteByte python code 

<python code>
import ctypes

dll = ctypes.CDLL('./Susi4.dll')
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)


dll.SusiSMBReadByte.restype = ctypes.c_uint
dll.SusiSMBReadByte.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.c_uint8, ctypes.POINTER(ctypes.c_uint8)]

def SusiSMBReadByte_py(bus_id, device_addr, command):
    """
    Reads a single byte from an SMBus device.

    Args:
        bus_id (int): SMBus bus ID (e.g., SUSI_ID_SMBUS_EXTERNAL)
        device_addr (int): 7-bit I2C address of the device
        command (int): Offset of the register or command to read

    Returns:
        tuple: A tuple containing the status code and the read byte value. 
               The status code will be SUSI_STATUS_SUCCESS if successful.
    """
    p_buffer = ctypes.c_uint8()
    status = dll.SusiSMBReadByte(bus_id, device_addr, command, ctypes.byref(p_buffer))
    return status, p_buffer.value


dll.SusiSMBWriteByte.restype = ctypes.c_uint
dll.SusiSMBWriteByte.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.c_uint8, ctypes.c_uint8]

def SusiSMBWriteByte_py(bus_id, device_addr, command, data):
    """
    Writes a single byte to an SMBus device.

    Args:
        bus_id (int): SMBus bus ID (e.g., SUSI_ID_SMBUS_EXTERNAL)
        device_addr (int): 7-bit I2C address of the device
        command (int): Offset of the register or command to write
        data (int): Byte value to write

    Returns:
        int: Status code. SUSI_STATUS_SUCCESS if successful.
    """
    status = dll.SusiSMBWriteByte(bus_id, device_addr, command, data)
    return status

# ... (Definitions of other functions, such as SusiSMBReadWord, SusiSMBWriteWord, etc.)
<code end>

**Usage Example:**

<python code>
# Read a single byte from an SMBus device
status, byte_value = SusiSMBReadByte_py(SUSI_ID_SMBUS_EXTERNAL, 0x50, 0x00)

if status == SUSI_STATUS_SUCCESS:
    print(f"Successfully read byte: {byte_value}")
else:
    print(f"Failed to read byte, error code: {hex(status)}")

# Write a single byte to an SMBus device
status = SusiSMBWriteByte_py(SUSI_ID_SMBUS_EXTERNAL, 0x50, 0x00, 0xAA)

if status == SUSI_STATUS_SUCCESS:
    print("Successfully wrote byte")
else:
    print(f"Failed to write byte, error code: {hex(status)}")
<code end>

**Notes:**

* Replace `SUSI_ID_SMBUS_EXTERNAL` with the actual SMBus bus ID you want to use.
* Replace `0x50` with the actual I2C address of the device you want to access.
* Replace `0x00` with the actual offset of the register or command you want to read or write.
* Modify the code as needed to fit your application.

You can define Python versions of other SMBus-related functions in a similar way. 


### 12.1.1 python code SusiSMBReadWord SusiSMBWriteWord python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
dll.SusiLibInitialize.restype = ctypes.c_uint32
status = dll.SusiLibInitialize()
if status != 0:
    print(f"SusiLibInitialize failed with error code: {hex(status)}")
    exit()

dll.SusiSMBReadWord.restype = ctypes.c_uint
dll.SusiSMBReadWord.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.c_uint8, ctypes.POINTER(ctypes.c_uint16)]

dll.SusiSMBWriteWord.restype = ctypes.c_uint
dll.SusiSMBWriteWord.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.c_uint8, ctypes.c_uint16]


# === Usage Example ===
p_word_value = ctypes.c_uint16()
status = dll.SusiSMBReadWord(SUSI_ID_SMBUS_EXTERNAL, 0x50, 0x00, ctypes.byref(p_word_value))
if status == 0:
    print(f"SusiSMBReadWord successful, value: {hex(p_word_value.value)}")
else:
    print(f"SusiSMBReadWord failed with error code: {hex(status)}")


status = dll.SusiSMBWriteWord(SUSI_ID_SMBUS_EXTERNAL, 0x50, 0x00, 0xAAAA)
if status == 0:
    print("SusiSMBWriteWord successful")
else:
    print(f"SusiSMBWriteWord failed with error code: {hex(status)}")


dll.SusiLibUninitialize.restype = ctypes.c_uint32
status = dll.SusiLibUninitialize()
if status != 0:
    print(f"SusiLibUninitialize failed with error code: {hex(status)}")
    exit()
<code end>

**Notes:**

* Replace `SUSI_ID_SMBUS_EXTERNAL` with the actual SMBus bus ID you want to use.
* Replace `0x50` with the actual I2C address of the device you want to access.
* Replace `0x00` with the actual offset of the register or command you want to read or write.
* Modify the code as needed to fit your application. 



### 12.1.1 python code SusiSMBReceiveByte SusiSMBSendByte python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
dll.SusiLibInitialize.restype = ctypes.c_uint32
status = dll.SusiLibInitialize()
if status != 0:
    print(f"SusiLibInitialize failed with error code: {hex(status)}")
    exit()

dll.SusiSMBReceiveByte.restype = ctypes.c_uint
dll.SusiSMBReceiveByte.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.POINTER(ctypes.c_uint8)]

dll.SusiSMBSendByte.restype = ctypes.c_uint
dll.SusiSMBSendByte.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.c_uint8]

# === Usage Example ===

p_byte_value = ctypes.c_uint8()
status = dll.SusiSMBReceiveByte(SUSI_ID_SMBUS_EXTERNAL, 0x50, ctypes.byref(p_byte_value))
if status == 0:
    print(f"SusiSMBReceiveByte successful, value: {hex(p_byte_value.value)}")
else:
    print(f"SusiSMBReceiveByte failed with error code: {hex(status)}")

status = dll.SusiSMBSendByte(SUSI_ID_SMBUS_EXTERNAL, 0x50, 0xAA)
if status == 0:
    print("SusiSMBSendByte successful")
else:
    print(f"SusiSMBSendByte failed with error code: {hex(status)}")

dll.SusiLibUninitialize.restype = ctypes.c_uint32
status = dll.SusiLibUninitialize()
if status != 0:
    print(f"SusiLibUninitialize failed with error code: {hex(status)}")
    exit()
<code end>

**Notes:**

* Replace `SUSI_ID_SMBUS_EXTERNAL` with the actual SMBus bus ID you want to use.
* Replace `0x50` with the actual I2C address of the device you want to access.
* Replace `0x00` with the actual offset of the register or command you want to read or write.
* Modify the code as needed to fit your application. 



### 12.1.1 python code SusiSMBReadQuick SusiSMBWriteQuick python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
dll.SusiLibInitialize.restype = ctypes.c_uint32
status = dll.SusiLibInitialize()
if status != 0:
    print(f"SusiLibInitialize failed with error code: {hex(status)}")
    exit()
	
dll.SusiSMBReadQuick.restype = ctypes.c_uint
dll.SusiSMBReadQuick.argtypes = [ctypes.c_uint, ctypes.c_uint8]

dll.SusiSMBWriteQuick.restype = ctypes.c_uint
dll.SusiSMBWriteQuick.argtypes = [ctypes.c_uint, ctypes.c_uint8]

# === Usage Example ===

p_byte_value = ctypes.c_uint8()

status = dll.SusiSMBReadQuick(SUSI_ID_SMBUS_EXTERNAL, 0x50)
if status == 0:
    print("SusiSMBReadQuick successful")
else:
    print(f"SusiSMBReadQuick failed with error code: {hex(status)}")

status = dll.SusiSMBWriteQuick(SUSI_ID_SMBUS_EXTERNAL, 0x50)
if status == 0:
    print("SusiSMBWriteQuick successful")
else:
    print(f"SusiSMBWriteQuick failed with error code: {hex(status)}")

dll.SusiLibUninitialize.restype = ctypes.c_uint32
status = dll.SusiLibUninitialize()
if status != 0:
    print(f"SusiLibUninitialize failed with error code: {hex(status)}")
    exit()
<code end>

**Notes:**

* Replace `SUSI_ID_SMBUS_EXTERNAL` with the actual SMBus bus ID you want to use.
* Replace `0x50` with the actual I2C address of the device you want to access.
* Replace `0x00` with the actual offset of the register or command you want to read or write.
* Modify the code as needed to fit your application. 





### 12.1.1 python code SusiSMBReadBlock SusiSMBWriteBlock python code 

<python code>
import ctypes

dll = ctypes.CDLL('./Susi4.dll')
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiSMBReadBlock.restype = ctypes.c_uint
dll.SusiSMBReadBlock.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.c_uint8, ctypes.POINTER(ctypes.c_uint8), ctypes.POINTER(ctypes.c_uint32)]

dll.SusiSMBWriteBlock.restype = ctypes.c_uint
dll.SusiSMBWriteBlock.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.c_uint8, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32]
# === Usage Example ===

block_size = ctypes.c_uint32(32)  # Assuming we want to read 32 bytes
buffer = (ctypes.c_uint8 * block_size.value)()  # Create a buffer of size block_size
status = dll.SusiSMBReadBlock(SUSI_ID_SMBUS_EXTERNAL, 0x50, 0x00, buffer, ctypes.byref(block_size))
if status == 0:
    print(f"SusiSMBReadBlock successful, read {block_size.value} bytes: {list(buffer)}")
else:
    print(f"SusiSMBReadBlock failed with error code: {hex(status)}")

data_to_write = (ctypes.c_uint8 * 32)(*[i for i in range(32)])  # Example data
status = dll.SusiSMBWriteBlock(SUSI_ID_SMBUS_EXTERNAL, 0x50, 0x00, data_to_write, 32)
if status == 0:
    print("SusiSMBWriteBlock successful")
else:
    print(f"SusiSMBWriteBlock failed with error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**

* Replace `SUSI_ID_SMBUS_EXTERNAL` with the actual SMBus bus ID you want to use.
* Replace `0x50` with the actual I2C address of the device you want to access.
* Replace `0x00` with the actual offset of the register or command you want to read or write.
* Modify the code as needed to fit your application. 





### 12.1.1 python code SusiSMBI2CReadBlock SusiSMBI2CWriteBlock python code 

<python code>
import ctypes

dll = ctypes.CDLL('./Susi4.dll')
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiSMBI2CReadBlock.restype = ctypes.c_uint
dll.SusiSMBI2CReadBlock.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.c_uint8, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32]
dll.SusiSMBI2CWriteBlock.restype = ctypes.c_uint
dll.SusiSMBI2CWriteBlock.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.c_uint8, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32]

# === Usage Example ===
block_size = ctypes.c_uint32(32)  # Assuming we want to read 32 bytes
buffer = (ctypes.c_uint8 * block_size.value)()  # Create a buffer of size block_size
status = dll.SusiSMBI2CReadBlock(SUSI_ID_SMBUS_EXTERNAL, 0x50, 0x00, buffer, block_size)
if status == 0:
    print(f"SusiSMBI2CReadBlock successful, read {block_size.value} bytes: {list(buffer)}")
else:
    print(f"SusiSMBI2CReadBlock failed with error code: {hex(status)}")

data_to_write = (ctypes.c_uint8 * 32)(*[i for i in range(32)])  # Example data
status = dll.SusiSMBI2CWriteBlock(SUSI_ID_SMBUS_EXTERNAL, 0x50, 0x00, data_to_write, 32)
if status == 0:
    print("SusiSMBI2CWriteBlock successful")
else:
    print(f"SusiSMBI2CWriteBlock failed with error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**

* Replace `SUSI_ID_SMBUS_EXTERNAL` with the actual SMBus bus ID you want to use.
* Replace `0x50` with the actual I2C address of the device you want to access.
* Replace `0x00` with the actual offset of the register or command you want to read or write.
* Modify the code as needed to fit your application. 




### 12.1.1 python code SusiI2CWriteReadCombine python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiI2CWriteReadCombine.restype = ctypes.c_uint
dll.SusiI2CWriteReadCombine.argtypes = [ctypes.c_uint, ctypes.c_uint8, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32]

# === Usage Example ===
write_data = (ctypes.c_uint8 * 2)(0x10, 0x20)  # Example write data
read_buffer = (ctypes.c_uint8 * 4)()  # Read data buffer
status = dll.SusiI2CWriteReadCombine(SUSI_ID_I2C_EXTERNAL, 0x50, write_data, 2, read_buffer, 4)
if status == 0:
    print(f"SusiI2CWriteReadCombine successful, read data: {list(read_buffer)}")
else:
    print(f"SusiI2CWriteReadCombine failed with error code: {hex(status)}")
	
# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_GPIO(0)`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 



### 12.1.1 python code SusiI2CReadTransfer python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiI2CReadTransfer.restype = ctypes.c_uint
dll.SusiI2CReadTransfer.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32]

read_buffer = (ctypes.c_uint8 * 4)()  # Read data buffer
status = dll.SusiI2CReadTransfer(SUSI_ID_I2C_EXTERNAL, SUSI_I2C_ENC_7BIT_ADDR(0x50), SUSI_I2C_ENC_STD_CMD(0x00), read_buffer, 4)
if status == 0:
    print(f"SusiI2CReadTransfer successful, read data: {list(read_buffer)}")
else:
    print(f"SusiI2CReadTransfer failed with error code: {hex(status)}")
# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_GPIO(0)`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 



### 12.1.1 python code SusiI2CWriteTransfer python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')
# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)
dll.SusiI2CWriteTransfer.restype = ctypes.c_uint
dll.SusiI2CWriteTransfer.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32]

write_data = (ctypes.c_uint8 * 4)(0x10, 0x20, 0x30, 0x40)  # Example write data
status = dll.SusiI2CWriteTransfer(SUSI_ID_I2C_EXTERNAL, SUSI_I2C_ENC_7BIT_ADDR(0x50), SUSI_I2C_ENC_STD_CMD(0x00), write_data, 4)
if status == 0:
    print("SusiI2CWriteTransfer successful")
else:
    print(f"SusiI2CWriteTransfer failed with error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_GPIO(0)`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 



### 12.1.1 SusiI2CProbeDevice python code 
# Only Probes the I2C bus for a device at the specified address. This function sends a simple I2C address frame to check if a device responds.
# As if check i2c supported --> use function SusiBoardGetValue.
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')
# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)
dll.SusiI2CProbeDevice.restype = ctypes.c_uint
dll.SusiI2CProbeDevice.argtypes = [ctypes.c_uint, ctypes.c_uint32]

status = dll.SusiI2CProbeDevice(SUSI_ID_I2C_EXTERNAL, SUSI_I2C_ENC_7BIT_ADDR(0x50))
if status == 0:
    print("SusiI2CProbeDevice successful, device found")
else:
    print(f"SusiI2CProbeDevice failed with error code: {hex(status)}")
# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_GPIO(0)`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 


### 12.1.1 python code SusiI2CGetFrequency SusiI2CSetFrequency python code 
<python code>
import ctypes
# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')
# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)
dll.SusiI2CGetFrequency.restype = ctypes.c_uint
dll.SusiI2CGetFrequency.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiI2CSetFrequency.restype = ctypes.c_uint
dll.SusiI2CSetFrequency.argtypes = [ctypes.c_uint, ctypes.c_uint32]

frequency = ctypes.c_uint32()
status = dll.SusiI2CGetFrequency(SUSI_ID_I2C_EXTERNAL, ctypes.byref(frequency))
if status == 0:
    print(f"SusiI2CGetFrequency successful, frequency: {frequency.value} KHz")
else:
    print(f"SusiI2CGetFrequency failed with error code: {hex(status)}")

status = dll.SusiI2CSetFrequency(SUSI_ID_I2C_EXTERNAL, 400)  # Set frequency to 400 KHz
if status == 0:
    print("SusiI2CSetFrequency successful")
else:
    print(f"SusiI2CSetFrequency failed with error code: {hex(status)}")
# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_GPIO(0)`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 


### 12.1.1 python code SusiI2CGetCaps python code 
<python code>
import ctypes
# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')
# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)
dll.SusiI2CGetCaps.restype = ctypes.c_uint
dll.SusiI2CGetCaps.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]


max_block_length = ctypes.c_uint32()
status = dll.SusiI2CGetCaps(SUSI_ID_I2C_EXTERNAL, SUSI_ID_I2C_MAXIMUM_BLOCK_LENGTH, ctypes.byref(max_block_length))
if status == 0:
    print(f"SusiI2CGetCaps successful, maximum block length: {max_block_length.value}")
else:
    print(f"SusiI2CGetCaps failed with error code: {hex(status)}")
# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_GPIO(0)`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 


### 12.1.1 python code SusiGPIOGetCaps python code 
<python code>
import ctypes
# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')
# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)
dll.SusiGPIOGetCaps.restype = ctypes.c_uint
dll.SusiGPIOGetCaps.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]

input_support = ctypes.c_uint32()
status = dll.SusiGPIOGetCaps(SUSI_ID_GPIO(0), SUSI_ID_GPIO_INPUT_SUPPORT, ctypes.byref(input_support))
if status == 0:
    print(f"SusiGPIOGetCaps successful, GPIO 0 input support: {bool(input_support.value)}")
else:
    print(f"SusiGPIOGetCaps failed with error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_I2C_EXTERNAL`, `SUSI_ID_GPIO(0)`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 


### 12.1.1 python code SusiGPIOGetDirection SusiGPIOSetDirection python code 
<python code>
import ctypes
# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')
# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)
dll.SusiGPIOGetDirection.restype = ctypes.c_uint
dll.SusiGPIOGetDirection.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiGPIOSetDirection.restype = ctypes.c_uint
dll.SusiGPIOSetDirection.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.c_uint32]

gpio_direction = ctypes.c_uint32()
status = dll.SusiGPIOGetDirection(SUSI_ID_GPIO(0), 1, ctypes.byref(gpio_direction))
if status == 0:
    print(f"SusiGPIOGetDirection successful, GPIO 0 direction: {'Output' if gpio_direction.value == 0 else 'Input'}")
else:
    print(f"SusiGPIOGetDirection failed with error code: {hex(status)}")

status = dll.SusiGPIOSetDirection(SUSI_ID_GPIO(0), 1, SUSI_GPIO_OUTPUT)  # Set GPIO 0 to output mode
if status == 0:
    print("SusiGPIOSetDirection successful")
else:
    print(f"SusiGPIOSetDirection failed with error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_GPIO(0)`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 



### 12.1.1 python code SusiGPIOGetLevel SusiGPIOSetLevel python code 
<python code>
import ctypes
# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')
# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiGPIOGetLevel.restype = ctypes.c_uint
dll.SusiGPIOGetLevel.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiGPIOSetLevel.restype = ctypes.c_uint
dll.SusiGPIOSetLevel.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.c_uint32]

gpio_level = ctypes.c_uint32()
status = dll.SusiGPIOGetLevel(SUSI_ID_GPIO(0), 1, ctypes.byref(gpio_level))
if status == 0:
    print(f"SusiGPIOGetLevel successful, GPIO 0 level: {'High' if gpio_level.value else 'Low'}")
else:
    print(f"SusiGPIOGetLevel failed with error code: {hex(status)}")

status = dll.SusiGPIOSetLevel(SUSI_ID_GPIO(0), 1, SUSI_GPIO_HIGH)  # Set GPIO 0 to high level
if status == 0:
    print("SusiGPIOSetLevel successful")
else:
    print(f"SusiGPIOSetLevel failed with error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace  `SUSI_ID_GPIO(0)`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 



### 12.1.1 python code SusiVgaGetBacklightEnable SusiVgaSetBacklightEnable python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiVgaGetBacklightEnable.restype = ctypes.c_uint
dll.SusiVgaGetBacklightEnable.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiVgaSetBacklightEnable.restype = ctypes.c_uint
dll.SusiVgaSetBacklightEnable.argtypes = [ctypes.c_uint, ctypes.c_uint32]

backlight_id = SUSI_ID_BACKLIGHT_1  # Use backlight ID 1

enable_status = ctypes.c_uint32()
status = dll.SusiVgaGetBacklightEnable(backlight_id, ctypes.byref(enable_status))
if status == 0:
    print(f"Backlight enable status: {'Enabled' if enable_status.value else 'Disabled'}")
else:
    print(f"Failed to get backlight enable status, error code: {hex(status)}")

enable_status = ctypes.c_uint32()
status = dll.SusiVgaGetBacklightEnable(backlight_id, ctypes.byref(enable_status))
if status == 0:
    print(f"Backlight enable status: {'Enabled' if enable_status.value else 'Disabled'}")
else:
    print(f"Failed to get backlight enable status, error code: {hex(status)}")
	
# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_BACKLIGHT_1` with the actual backlight ID you want to use.
* Modify the code as needed to fit your application. 



### 12.1.1 python code SusiVgaGetBacklightBrightness SusiVgaSetBacklightBrightness python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiVgaGetBacklightBrightness.restype = ctypes.c_uint
dll.SusiVgaGetBacklightBrightness.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiVgaSetBacklightBrightness.restype = ctypes.c_uint
dll.SusiVgaSetBacklightBrightness.argtypes = [ctypes.c_uint, ctypes.c_uint32]

backlight_id = SUSI_ID_BACKLIGHT_1  # Use backlight ID 1

brightness = ctypes.c_uint32()
status = dll.SusiVgaGetBacklightBrightness(backlight_id, ctypes.byref(brightness))
if status == 0:
    print(f"Backlight brightness: {brightness.value}")
else:
    print(f"Failed to get backlight brightness, error code: {hex(status)}")

status = dll.SusiVgaSetBacklightBrightness(backlight_id, 50)  # Set backlight brightness to 50%
if status == 0:
    print("Backlight brightness set")
else:
    print(f"Failed to set backlight brightness, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_BACKLIGHT_1` with the actual backlight ID you want to use.
* Modify the code as needed to fit your application. 


### 12.1.1 python code SusiVgaGetBacklightLevel SusiVgaSetBacklightLevel python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiVgaGetBacklightLevel.restype = ctypes.c_uint
dll.SusiVgaGetBacklightLevel.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiVgaSetBacklightLevel.restype = ctypes.c_uint
dll.SusiVgaSetBacklightLevel.argtypes = [ctypes.c_uint, ctypes.c_uint32]

backlight_id = SUSI_ID_BACKLIGHT_1  # Use backlight ID 1

level = ctypes.c_uint32()
status = dll.SusiVgaGetBacklightLevel(backlight_id, ctypes.byref(level))
if status == 0:
    print(f"Backlight level: {level.value}")
else:
    print(f"Failed to get backlight level, error code: {hex(status)}")

status = dll.SusiVgaSetBacklightLevel(backlight_id, 5)  # Set backlight level to 5
if status == 0:
    print("Backlight level set")
else:
    print(f"Failed to set backlight level, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_BACKLIGHT_1` with the actual backlight ID you want to use.
* Modify the code as needed to fit your application. 


### 12.1.1 python code SusiVgaGetPolarity SusiVgaSetPolarity python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiVgaGetPolarity.restype = ctypes.c_uint
dll.SusiVgaGetPolarity.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiVgaSetPolarity.restype = ctypes.c_uint
dll.SusiVgaSetPolarity.argtypes = [ctypes.c_uint, ctypes.c_uint32]


backlight_id = SUSI_ID_BACKLIGHT_1  # Use backlight ID 1
polarity = ctypes.c_uint32()
status = dll.SusiVgaGetPolarity(backlight_id, ctypes.byref(polarity))
if status == 0:
    print(f"Backlight PWM invert: {'Inverted' if polarity.value else 'Not inverted'}")
else:
    print(f"Failed to get backlight PWM invert status, error code: {hex(status)}")

status = dll.SusiVgaSetPolarity(backlight_id, SUSI_BACKLIGHT_POLARITY_ON)  # Set backlight PWM invert
if status == 0:
    print("Backlight PWM invert set")
else:
    print(f"Failed to set backlight PWM invert, error code: {hex(status)}")
# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_BACKLIGHT_1` with the actual backlight ID you want to use.
* Modify the code as needed to fit your application. 





### 12.1.1 python code SusiVgaGetFrequency SusiVgaSetFrequency python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiVgaGetFrequency.restype = ctypes.c_uint
dll.SusiVgaGetFrequency.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiVgaSetFrequency.restype = ctypes.c_uint
dll.SusiVgaSetFrequency.argtypes = [ctypes.c_uint, ctypes.c_uint32]

backlight_id = SUSI_ID_BACKLIGHT_1  # Use backlight ID 1

frequency = ctypes.c_uint32()
status = dll.SusiVgaGetFrequency(backlight_id, ctypes.byref(frequency))
if status == 0:
    print(f"Backlight PWM frequency: {frequency.value}")
else:
    print(f"Failed to get backlight PWM frequency, error code: {hex(status)}")

status = dll.SusiVgaSetFrequency(backlight_id, 200)  # Set backlight PWM frequency to 200 Hz
if status == 0:
    print("Backlight PWM frequency set")
else:
    print(f"Failed to set backlight PWM frequency, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_BACKLIGHT_1` with the actual backlight ID you want to use.
* Modify the code as needed to fit your application. 


### 12.1.1 python code SusiVgaGetCaps  python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiVgaGetCaps.restype = ctypes.c_uint
dll.SusiVgaGetCaps.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]

backlight_id = SUSI_ID_BACKLIGHT_1  # Use backlight ID 1

max_brightness = ctypes.c_uint32()
status = dll.SusiVgaGetCaps(backlight_id, SUSI_ID_VGA_BRIGHTNESS_MAXIMUM, ctypes.byref(max_brightness))
if status == 0:
    print(f"Maximum backlight brightness: {max_brightness.value}")
else:
    print(f"Failed to get maximum backlight brightness, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_BACKLIGHT_1` with the actual backlight ID you want to use.
* Modify the code as needed to fit your application. 




### 12.1.1 python code SusiStorageGetCaps  python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiStorageGetCaps.restype = ctypes.c_uint
dll.SusiStorageGetCaps.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]
storage_id = SUSI_ID_STORAGE_STD  # Use standard storage area ID

total_size = ctypes.c_uint32()
status = dll.SusiStorageGetCaps(storage_id, SUSI_ID_STORAGE_TOTAL_SIZE, ctypes.byref(total_size))
if status == 0:
    print(f"Total storage area size: {total_size.value} bytes")
else:
    print(f"Failed to get total storage area size, error code: {hex(status)}")
# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_STORAGE_STD` with the actual storage area ID you want to use.
* Modify the code as needed to fit your application. 





### 12.1.1 python code SusiStorageAreaRead SusiStorageAreaWrite python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiStorageAreaRead.restype = ctypes.c_uint
dll.SusiStorageAreaRead.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32]
dll.SusiStorageAreaWrite.restype = ctypes.c_uint
dll.SusiStorageAreaWrite.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32]

storage_id = SUSI_ID_STORAGE_STD  # Use standard storage area ID
read_buffer = (ctypes.c_uint8 * 64)()  # Create a 64-byte read buffer
status = dll.SusiStorageAreaRead(storage_id, 0, read_buffer, 64)
if status == 0:
    print(f"Data read: {list(read_buffer)}")
else:
    print(f"Failed to read storage area data, error code: {hex(status)}")

write_data = (ctypes.c_uint8 * 64)(*[i for i in range(64)])  # Create example write data
status = dll.SusiStorageAreaWrite(storage_id, 0, write_data, 64)
if status == 0:
    print("Data written to storage area")
else:
    print(f"Failed to write storage area data, error code: {hex(status)}")
# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_STORAGE_STD` with the actual storage area ID you want to use.
* Modify the code as needed to fit your application. 






### 12.1.1 python code SusiStorageAreaSetUnlock SusiStorageAreaSetLock python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiStorageAreaSetUnlock.restype = ctypes.c_uint
dll.SusiStorageAreaSetUnlock.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32]
dll.SusiStorageAreaSetLock.restype = ctypes.c_uint
dll.SusiStorageAreaSetLock.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32]

storage_id = SUSI_ID_STORAGE_STD  # Use standard storage area ID
unlock_key = (ctypes.c_uint8 * 8)(0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF)  # Set unlock key
status = dll.SusiStorageAreaSetUnlock(storage_id, unlock_key, 8)
if status == 0:
    print("Storage area unlocked")
else:
    print(f"Failed to unlock storage area, error code: {hex(status)}")

status = dll.SusiStorageAreaSetLock(storage_id, None, 0)  # Lock storage area
if status == 0:
    print("Storage area locked")
else:
    print(f"Failed to lock storage area, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_STORAGE_STD` with the actual storage area ID you want to use.
* Modify the code as needed to fit your application. 





### 12.1.1 python code FanControlGetCaps  python code 

#//SusiFanControlGetCaps is only for getting capabilities. As if getting fanspeed please use dll.SusiBoardGetValue function.
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiFanControlGetCaps.restype = ctypes.c_uint
dll.SusiFanControlGetCaps.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]
fan_id = SUSI_ID_HWM_FAN_CPU  # Use CPU fan ID
support_flags = ctypes.c_uint32()
status = dll.SusiFanControlGetCaps(fan_id, SUSI_ID_FC_CONTROL_SUPPORT_FLAGS, ctypes.byref(support_flags))
if status == 0:
    print(f"Fan control supported features: {hex(support_flags.value)}")
else:
    print(f"Failed to get fan control supported features, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**

* Replace `SUSI_ID_HWM_FAN_CPU` etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 





### 12.1.1 python code SusiFanControlGetConfig  python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiFanControlGetConfig.restype = ctypes.c_uint
dll.SusiFanControlGetConfig.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint32)]


# Define structures
class AutoFan(ctypes.Structure):
    _fields_ = [
        ("TmlSource", ctypes.c_uint32),
        ("OpMode", ctypes.c_uint32),
        ("LowStopLimit", ctypes.c_uint32),
        ("LowLimit", ctypes.c_uint32),
        ("HighLimit", ctypes.c_uint32),
        ("MinPWM", ctypes.c_uint32),
        ("MaxPWM", ctypes.c_uint32),
        ("MinRPM", ctypes.c_uint32),
        ("MaxRPM", ctypes.c_uint32),
    ]

class SusiFanControl(ctypes.Structure):
    _fields_ = [
        ("Mode", ctypes.c_uint32),
        ("PWM", ctypes.c_uint32),
        ("AutoControl", AutoFan),
    ]
fan_id = SUSI_ID_HWM_FAN_CPU  # Use CPU fan ID
fan_config = SusiFanControl()
status = dll.SusiFanControlGetConfig(fan_id, ctypes.byref(fan_config))
if status == 0:
    print(f"Fan control configuration: Mode={fan_config.Mode}, PWM={fan_config.PWM}")
else:
    print(f"Failed to get fan control configuration, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**

* Replace `SUSI_ID_HWM_FAN_CPU` etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 
* Note that the parameter types of `SusiFanControlGetConfig` are defined as `SusiFanControl *` in your .h definition, but in Python, we need to pass the address of the structure, so we use `ctypes.byref(fan_config)`.

	


### 12.1.1 python code SusiFanControlSetConfig  python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiFanControlSetConfig.restype = ctypes.c_uint
dll.SusiFanControlSetConfig.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint32)]

# Define structures
class AutoFan(ctypes.Structure):
    _fields_ = [
        ("TmlSource", ctypes.c_uint32),
        ("OpMode", ctypes.c_uint32),
        ("LowStopLimit", ctypes.c_uint32),
        ("LowLimit", ctypes.c_uint32),
        ("HighLimit", ctypes.c_uint32),
        ("MinPWM", ctypes.c_uint32),
        ("MaxPWM", ctypes.c_uint32),
        ("MinRPM", ctypes.c_uint32),
        ("MaxRPM", ctypes.c_uint32),
    ]

class SusiFanControl(ctypes.Structure):
    _fields_ = [
        ("Mode", ctypes.c_uint32),
        ("PWM", ctypes.c_uint32),
        ("AutoControl", AutoFan),
    ]

fan_id = SUSI_ID_HWM_FAN_CPU  # Use CPU fan ID

fan_config = SusiFanControl(Mode=SUSI_FAN_CTRL_MODE_MANUAL, PWM=50)  # Set to manual mode, PWM is 50%
status = dll.SusiFanControlSetConfig(fan_id, ctypes.byref(fan_config))
if status == 0:
    print("Fan control configuration set")
else:
    print(f"Failed to set fan control configuration, error code: {hex(status)}")


# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_HWM_FAN_CPU` etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 
* Note that the parameter types of `SusiFanControlSetConfig` are defined as `SusiFanControl *` in your `.h` file, but in Python, we need to pass the address of the structure, so we use `ctypes.byref(fan_config)`.







### 12.1.1 python code SusiThermalProtectionGetCaps  python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiThermalProtectionGetCaps.restype = ctypes.c_uint
dll.SusiThermalProtectionGetCaps.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]

thermal_id = SUSI_ID_THERMAL_PROTECT_1  # Use Thermal Protection ID 1

support_flags = ctypes.c_uint32()
status = dll.SusiThermalProtectionGetCaps(thermal_id, SUSI_ID_TP_EVENT_SUPPORT_FLAGS, ctypes.byref(support_flags))
if status == 0:
    print(f"Thermal Protection supported features: {hex(support_flags.value)}")
else:
    print(f"Failed to get Thermal Protection supported features, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**

* Replace `SUSI_ID_THERMAL_PROTECT_1`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 


### 12.1.1 python code SusiThermalProtectionSetConfig  python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiThermalProtectionSetConfig.restype = ctypes.c_uint
dll.SusiThermalProtectionSetConfig.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint32)]

# Define structures

class SusiThermalProtect(ctypes.Structure):
    _fields_ = [
        ("SourceId", ctypes.c_uint32),
        ("EventType", ctypes.c_uint32),
        ("SendEventTemperature", ctypes.c_uint32),
        ("ClearEventTemperature", ctypes.c_uint32),
    ]

thermal_id = SUSI_ID_THERMAL_PROTECT_1  # Use Thermal Protection ID 1
thermal_config = SusiThermalProtect(SourceId=SUSI_ID_HWM_TEMP_CPU, EventType=SUSI_THERMAL_EVENT_SHUTDOWN, SendEventTemperature=SUSI_ENCODE_CELCIUS(80), ClearEventTemperature=SUSI_ENCODE_CELCIUS(75))
status = dll.SusiThermalProtectionSetConfig(thermal_id, ctypes.byref(thermal_config))
if status == 0:
    print("Thermal Protection configuration set")
else:
    print(f"Failed to set Thermal Protection configuration, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**

* Replace `SUSI_ID_HWM_TEMP_CPU`, `SUSI_ID_THERMAL_PROTECT_1`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 
* `SusiThermalProtectionSetConfig` and `SusiThermalProtectionGetConfig` also need to pass the address of the structure.



### 12.1.1 python code SusiThermalProtectionGetConfig  python code 

<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiThermalProtectionGetConfig.restype = ctypes.c_uint
dll.SusiThermalProtectionGetConfig.argtypes = [ctypes.c_uint, ctypes.POINTER(ctypes.c_uint32)]

# Define structures
class SusiThermalProtect(ctypes.Structure):
    _fields_ = [
        ("SourceId", ctypes.c_uint32),
        ("EventType", ctypes.c_uint32),
        ("SendEventTemperature", ctypes.c_uint32),
        ("ClearEventTemperature", ctypes.c_uint32),
    ]

thermal_id = SUSI_ID_THERMAL_PROTECT_1  # Use Thermal Protection ID 1

thermal_config = SusiThermalProtect()
status = dll.SusiThermalProtectionGetConfig(thermal_id, ctypes.byref(thermal_config))
if status == 0:
    print(f"Thermal Protection configuration: Source={thermal_config.SourceId}, Event Type={thermal_config.EventType}")
else:
    print(f"Failed to get Thermal Protection configuration, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**

* Replace `SUSI_ID_THERMAL_PROTECT_1`, etc. with the actual IDs you want to use.
* Modify the code as needed to fit your application. 
* `SusiThermalProtectionGetConfig` also need to pass the address of the structure.





### 12.1.1 python code SusiWDogGetCaps  python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiWDogGetCaps.restype = ctypes.c_uint
dll.SusiWDogGetCaps.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]
watchdog_id = SUSI_ID_WATCHDOG_1  # Use Watchdog ID 1

support_flags = ctypes.c_uint32()
status = dll.SusiWDogGetCaps(watchdog_id, SUSI_ID_WDT_SUPPORT_FLAGS, ctypes.byref(support_flags))
if status == 0:
    print(f"Watchdog supported features: {hex(support_flags.value)}")
else:
    print(f"Failed to get Watchdog supported features, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_WATCHDOG_1` with the actual Watchdog ID you want to use.
* Modify the code as needed to fit your application. 


### 12.1.1 python code SusiWDogStart  python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiWDogStart.restype = ctypes.c_uint
dll.SusiWDogStart.argtypes = [ctypes.c_uint, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_uint32]

watchdog_id = SUSI_ID_WATCHDOG_1  # Use Watchdog ID 1

delay_time = 10  # Delay time in seconds
event_time = 5  # Event time in seconds
reset_time = 15  # Reset time in seconds
event_type = SUSI_WDT_EVENT_TYPE_IRQ  # Event type is IRQ
status = dll.SusiWDogStart(watchdog_id, delay_time, event_time, reset_time, event_type)
if status == 0:
    print("Watchdog started")
else:
    print(f"Failed to start Watchdog, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_WATCHDOG_1` with the actual Watchdog ID you want to use.
* Modify the code as needed to fit your application. 




### 12.1.1 python code SusiWDogStop  python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiWDogStop.restype = ctypes.c_uint
dll.SusiWDogStop.argtypes = [ctypes.c_uint]
watchdog_id = SUSI_ID_WATCHDOG_1  # Use Watchdog ID 1

status = dll.SusiWDogStop(watchdog_id)
if status == 0:
    print("Watchdog stopped")
else:
    print(f"Failed to stop Watchdog, error code: {hex(status)}")
# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_WATCHDOG_1` with the actual Watchdog ID you want to use.
* Modify the code as needed to fit your application. 




### 12.1.1 python code SusiWDogTrigger  python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

dll.SusiWDogTrigger.restype = ctypes.c_uint
dll.SusiWDogTrigger.argtypes = [ctypes.c_uint]

watchdog_id = SUSI_ID_WATCHDOG_1  # Use Watchdog ID 1

status = dll.SusiWDogTrigger(watchdog_id)
if status == 0:
    print("Watchdog triggered")
else:
    print(f"Failed to trigger Watchdog, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**

* Replace `SUSI_ID_WATCHDOG_1` with the actual Watchdog ID you want to use.
* Modify the code as needed to fit your application. 




### 12.1.1 python code SusiWDogSetCallBack  python code 
<python code>
import ctypes

# Load the DLL file
dll = ctypes.CDLL('./Susi4.dll')

def watchdog_callback(context):
    print("Watchdog event triggered!")


# Define the return types and argument types of the functions
# ... (Previous code, including loading the DLL and defining SusiLibInitialize, etc.)

SUSI_WDT_INT_CALLBACK = ctypes.CFUNCTYPE(None, ctypes.c_void_p)
dll.SusiWDogSetCallBack.restype = ctypes.c_uint
dll.SusiWDogSetCallBack.argtypes = [ctypes.c_uint, SUSI_WDT_INT_CALLBACK, ctypes.c_void_p]

watchdog_id = SUSI_ID_WATCHDOG_1  # Use Watchdog ID 1

callback = SUSI_WDT_INT_CALLBACK(watchdog_callback)
status = dll.SusiWDogSetCallBack(watchdog_id, callback, None)
if status == 0:
    print("Watchdog callback function set")
else:
    print(f"Failed to set Watchdog callback function, error code: {hex(status)}")

# ... (Subsequent code, including SusiLibUninitialize, etc.)
<code end>

**Notes:**
* Replace `SUSI_ID_WATCHDOG_1` with the actual Watchdog ID you want to use.
* Modify the code as needed to fit your application. 
* `SusiWDogSetCallBack` uses `ctypes.CFUNCTYPE` to define the type of the callback function and passes the address of the callback function and an optional context parameter.




### 13.1.1 Get Fan Speed C/C++ Sample Code

<c code>
#include <stdio.h>
#include "susi4.h"

int main() {
    // Initialize the SUSI library
    SusiStatus_t status = SusiLibInitialize();
    if (status != SUSI_STATUS_SUCCESS) {
        printf("Failed to initialize SUSI library.\n");
        return 1;
    }

    // Get CPU fan speed
    uint32_t fanSpeed = 0;
    status = SusiBoardGetValue(SUSI_ID_HWM_FAN_CPU, &fanSpeed);
    if (status == SUSI_STATUS_SUCCESS) {
        printf("CPU fan speed: %u RPM\n", fanSpeed);
    } else {
        printf("Failed to get CPU fan speed.\n");
    }

    // Uninitialize the SUSI library
    SusiLibUninitialize();
    return 0;
}
<code end>

**Explanation:**

1. **Include Header:** The code includes the `susieee.h` header file, which contains the definitions for the SUSI API functions and constants.
2. **Initialize SUSI Library:** The `SusiLibInitialize()` function initializes the SUSI library. It's crucial to call this before using any other SUSI API functions.
3. **Get Fan Speed:**
    - `SusiBoardGetValue(SUSI_ID_HWM_FAN_CPU, &fanSpeed)` retrieves the CPU fan speed. 
    - `SUSI_ID_HWM_FAN_CPU` is the ID for the CPU fan.
    - The retrieved fan speed is stored in the `fanSpeed` variable.
4. **Print Fan Speed:** The code prints the retrieved fan speed to the console.
5. **Uninitialize SUSI Library:** The `SusiLibUninitialize()` function uninitializes the SUSI library and releases any resources held by the library.


### 13.1.1 Check Whether SMBus is Supported C/C++ Sample Code

<c code>
#include <stdio.h>
#include "susi4.h"

int main() {
    // Initialize the SUSI library
    SusiStatus_t status = SusiLibInitialize();
    if (status != SUSI_STATUS_SUCCESS) {
        printf("Failed to initialize SUSI library.\n");
        return 1;
    }

    // Check if SMBus is supported
    uint32_t smbusSupport = 0;
    status = SusiBoardGetValue(SUSI_ID_SMBUS_SUPPORTED, &smbusSupport);
    if (status == SUSI_STATUS_SUCCESS) {
        if (smbusSupport & SUSI_SMBUS_EXTERNAL_SUPPORTED) {
            printf("External SMBus is supported.\n");
        } else {
            printf("External SMBus is not supported.\n");
        }
    } else {
        printf("Failed to check SMBus support.\n");
    }

    // Uninitialize the SUSI library
    SusiLibUninitialize();
    return 0;
}
<code end>

**Explanation:**

1. **Include Header and Initialize Library:** Similar to the previous example.
2. **Check SMBus Support:**
    - `SusiBoardGetValue(SUSI_ID_SMBUS_SUPPORTED, &smbusSupport)` retrieves the SMBus support information.
    - `SUSI_ID_SMBUS_SUPPORTED` is the ID for checking SMBus support.
    - The retrieved value is stored in the `smbusSupport` variable.
3. **Evaluate Support:** The code checks if the `SUSI_SMBUS_EXTERNAL_SUPPORTED` bit is set in the `smbusSupport` variable. If it is, it means the external SMBus is supported.
4. **Print Result:** The code prints the result to the console.
5. **Uninitialize Library:** Similar to the previous example.

### 13.1.1 SusiBoardGetValue: Check Whether I2C is Supported C Code (c++)

<c code>
#include <stdio.h>
#include "susi4.h"

int main() {
    // Initialize the SUSI library
    SusiStatus_t status = SusiLibInitialize();
    if (status != SUSI_STATUS_SUCCESS) {
        printf("Failed to initialize SUSI library.\n");
        return 1;
    }

    // Check if I2C is supported
    uint32_t i2cSupport = 0;
    status = SusiBoardGetValue(SUSI_ID_I2C_SUPPORTED, &i2cSupport);
    if (status == SUSI_STATUS_SUCCESS) {
        if (i2cSupport & SUSI_I2C_EXTERNAL_SUPPORTED) {
            printf("External I2C is supported.\n");
        } else {
            printf("External I2C is not supported.\n");
        }
    } else {
        printf("Failed to check I2C support.\n");
    }

    // Uninitialize the SUSI library
    SusiLibUninitialize();
    return 0;
}
<code end>

**Explanation:**

This code is very similar to the SMBus support check. The key difference is the use of `SUSI_ID_I2C_SUPPORTED` and `SUSI_I2C_EXTERNAL_SUPPORTED` to check for I2C support. 





















### 13.1.1 I2C Probe C# Sample Code
** Only Probes the I2C bus for a device at the specified address. This function sends a simple I2C address frame to check if a device responds.
<c# code>
using System;
using Susi4.APIs; //refer susi4.cs

public class I2CProbeExample
{
    public static void Main(string[] args)
    {
        // Initialize the SUSI library
        UInt32 status = SusiLib.SusiLibInitialize();
        if (status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to initialize SUSI library.");
            return;
        }

        // I2C bus ID (e.g., external I2C)
        UInt32 i2cBusId = SusiI2C.SUSI_ID_I2C_EXTERNAL;

        // Iterate through I2C addresses (7-bit)
        for (byte address = 0x03; address < 0x78; address++)
        {
            // Encode the 7-bit address
            UInt32 encodedAddress = SusiI2C.SUSI_I2C_ENC_7BIT_ADDR(address);

            // Probe the device
            status = SusiI2C.SusiI2CProbeDevice(i2cBusId, encodedAddress);

            if (status == SusiStatus.SUSI_STATUS_SUCCESS)
            {
                Console.WriteLine("Device found at address: 0x" + address.ToString("X2"));
            }
        }

        // Uninitialize the SUSI library
        SusiLib.SusiLibUninitialize();
    }
}
<code end>

**Explanation:**

1. **Include Necessary Namespace:** The code includes the `Susi4.APIs` namespace, which contains the definitions for the SUSI API functions and constants.
2. **Initialize SUSI Library:** The `SusiLib.SusiLibInitialize()` function initializes the SUSI library.
3. **Set I2C Bus ID:** The `i2cBusId` variable is set to `SusiI2C.SUSI_ID_I2C_EXTERNAL`, indicating the external I2C bus.
4. **Iterate Through Addresses:** The code iterates through a range of 7-bit I2C addresses (0x03 to 0x77).
5. **Encode Address:** The `SusiI2C.SUSI_I2C_ENC_7BIT_ADDR()` function encodes the 7-bit address into the format required by the SUSI API.
6. **Probe Device:** The `SusiI2C.SusiI2CProbeDevice()` function attempts to communicate with a device at the specified address. If successful, it indicates that a device is present at that address.
7. **Print Result:** If a device is found, its address is printed to the console.
8. **Uninitialize SUSI Library:** The `SusiLib.SusiLibUninitialize()` function uninitializes the SUSI library.

### 13.1.1 Check Whether SMBus is Supported C# Sample Code

<c# code>
using System;
using Susi4.APIs;//refer susi4.cs

public class SMBusSupportCheck
{
    public static void Main(string[] args)
    {
        // Initialize the SUSI library
        UInt32 status = SusiLib.SusiLibInitialize();
        if (status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to initialize SUSI library.");
            return;
        }

        // Check if SMBus is supported
        UInt32 smbusSupport = 0;
        status = SusiBoard.SusiBoardGetValue(SusiBoard.SUSI_ID_SMBUS_SUPPORTED, ref smbusSupport);
        if (status == SusiStatus.SUSI_STATUS_SUCCESS)
        {
            if ((smbusSupport & SusiBoard.SUSI_SMBUS_EXTERNAL_SUPPORTED) != 0)
            {
                Console.WriteLine("External SMBus is supported.");
            }
            else
            {
                Console.WriteLine("External SMBus is not supported.");
            }
        }
        else
        {
            Console.WriteLine("Failed to check SMBus support.");
        }

        // Uninitialize the SUSI library
        SusiLib.SusiLibUninitialize();
    }
}
<code end>

**Explanation:**

1. **Include Namespace and Initialize Library:** Similar to the previous example.
2. **Check SMBus Support:**
    - `SusiBoard.SusiBoardGetValue(SusiBoard.SUSI_ID_SMBUS_SUPPORTED, ref smbusSupport)` retrieves the SMBus support information.
    - `SusiBoard.SUSI_ID_SMBUS_SUPPORTED` is the ID for checking SMBus support.
    - The retrieved value is stored in the `smbusSupport` variable.
3. **Evaluate Support:** The code checks if the `SusiBoard.SUSI_SMBUS_EXTERNAL_SUPPORTED` bit is set in the `smbusSupport` variable using a bitwise AND operation. If the result is non-zero, it means the external SMBus is supported.
4. **Print Result:** The code prints the result to the console.
5. **Uninitialize Library:** Similar to the previous example.


### 13.1.1 SusiBoardGetValue: Check Whether I2C is Supported C# Sample Code

<c# code>
using System;
using Susi4.APIs;//refer susi4.cs

public class I2CSupportCheck
{
    public static void Main(string[] args)
    {
        // Initialize the SUSI library
        UInt32 status = SusiLib.SusiLibInitialize();
        if (status != SusiStatus.SUSI_STATUS_SUCCESS)
        {
            Console.WriteLine("Failed to initialize SUSI library.");
            return;
        }

        // Check if I2C is supported
        UInt32 i2cSupport = 0;
        status = SusiBoard.SusiBoardGetValue(SusiBoard.SUSI_ID_I2C_SUPPORTED, ref i2cSupport);
        if (status == SusiStatus.SUSI_STATUS_SUCCESS)
        {
            if ((i2cSupport & SusiBoard.SUSI_I2C_EXTERNAL_SUPPORTED) != 0)
            {
                Console.WriteLine("External I2C is supported.");
            }
            else
            {
                Console.WriteLine("External I2C is not supported.");
            }
        }
        else
        {
            Console.WriteLine("Failed to check I2C support.");
        }

        // Uninitialize the SUSI library
        SusiLib.SusiLibUninitialize();
    }
}
<code end>

**Explanation:**

This code is very similar to the SMBus support check. The key differences are:

- It uses `SusiBoard.SUSI_ID_I2C_SUPPORTED` to retrieve the I2C support information.
- It checks for the `SusiBoard.SUSI_I2C_EXTERNAL_SUPPORTED` bit to determine if the external I2C bus is supported. 




### 13.1.1 SusiBoardGetValue:Get Fan Speed Python Sample Code

<python code>
import ctypes

# Load the SUSI4 DLL
dll = ctypes.CDLL('./Susi4.dll')

# Define the function signatures
dll.SusiLibInitialize.restype = ctypes.c_uint32
dll.SusiLibUninitialize.restype = ctypes.c_uint32
dll.SusiBoardGetValue.argtypes = [ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiBoardGetValue.restype = ctypes.c_uint32

def main():
    # Initialize the SUSI library
    status = dll.SusiLibInitialize()
    if status != 0:
        print("Failed to initialize SUSI library.")
        return

    # Get CPU fan speed
    fan_speed = ctypes.c_uint32(0)
    status = dll.SusiBoardGetValue(0x00022000, ctypes.byref(fan_speed))  # SUSI_ID_HWM_FAN_CPU
    if status == 0:
        print(f"CPU fan speed: {fan_speed.value} RPM")
    else:
        print("Failed to get CPU fan speed.")

    # Uninitialize the SUSI library
    dll.SusiLibUninitialize()

if __name__ == "__main__":
    main()
<code end>

**Explanation:**

1. **Import ctypes:** Import the `ctypes` module for interacting with the SUSI4 DLL.
2. **Load DLL:** Load the `Susi4.dll` using `ctypes.CDLL('./Susi4.dll')`.
3. **Define Function Signatures:** Define the return types and argument types for the SUSI API functions you'll be using. This ensures that Python correctly interacts with the DLL functions.
4. **Initialize SUSI Library:** Call `dll.SusiLibInitialize()` to initialize the SUSI library.
5. **Get Fan Speed:**
    - Create a `ctypes.c_uint32` object to store the fan speed value.
    - Call `dll.SusiBoardGetValue(0x00022000, ctypes.byref(fan_speed))` to retrieve the CPU fan speed. 
        - `0x00022000` is the `SUSI_ID_HWM_FAN_CPU` constant.
        - `ctypes.byref(fan_speed)` passes a reference to the `fan_speed` variable to the function.
6. **Print Fan Speed:** Print the retrieved fan speed (`fan_speed.value`) to the console.
7. **Uninitialize SUSI Library:** Call `dll.SusiLibUninitialize()` to uninitialize the SUSI library.


### 13.1.1 SusiBoardGetValue:Check Whether SMBus is Supported Python Sample Code

<python code>
import ctypes

# Load the SUSI4 DLL
dll = ctypes.CDLL('./Susi4.dll')

# Define the function signatures
dll.SusiLibInitialize.restype = ctypes.c_uint32
dll.SusiLibUninitialize.restype = ctypes.c_uint32
dll.SusiBoardGetValue.argtypes = [ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiBoardGetValue.restype = ctypes.c_uint32

def main():
    # Initialize the SUSI library
    status = dll.SusiLibInitialize()
    if status != 0:
        print("Failed to initialize SUSI library.")
        return

    # Check if SMBus is supported
    smbus_support = ctypes.c_uint32(0)
    status = dll.SusiBoardGetValue(0x00030000, ctypes.byref(smbus_support))  # SUSI_ID_SMBUS_SUPPORTED
    if status == 0:
        if smbus_support.value & 1:  # Check if the first bit (external SMBus) is set
            print("External SMBus is supported.")
        else:
            print("External SMBus is not supported.")
    else:
        print("Failed to check SMBus support.")

    # Uninitialize the SUSI library
    dll.SusiLibUninitialize()

if __name__ == "__main__":
    main()
<code end>

**Explanation:**

1. **Import ctypes and Load DLL:** Similar to the previous example.
2. **Define Function Signatures:** Similar to the previous example.
3. **Initialize SUSI Library:** Similar to the previous example.
4. **Check SMBus Support:**
    - Create a `ctypes.c_uint32` object to store the SMBus support value.
    - Call `dll.SusiBoardGetValue(0x00030000, ctypes.byref(smbus_support))` to retrieve the SMBus support information.
        - `0x00030000` is the `SUSI_ID_SMBUS_SUPPORTED` constant.
5. **Evaluate Support:** Check if the first bit (representing external SMBus support) is set in the `smbus_support.value` using a bitwise AND operation (`& 1`).
6. **Print Result:** Print the result to the console.
7. **Uninitialize SUSI Library:** Similar to the previous example.

### 13.1.1 SusiBoardGetValue:Check Whether I2C is Supported Python Sample Code

<python code>
import ctypes

# Load the SUSI4 DLL
dll = ctypes.CDLL('./Susi4.dll')

# Define the function signatures
dll.SusiLibInitialize.restype = ctypes.c_uint32
dll.SusiLibUninitialize.restype = ctypes.c_uint32
dll.SusiBoardGetValue.argtypes = [ctypes.c_uint32, ctypes.POINTER(ctypes.c_uint32)]
dll.SusiBoardGetValue.restype = ctypes.c_uint32

def main():
    # Initialize the SUSI library
    status = dll.SusiLibInitialize()
    if status != 0:
        print("Failed to initialize SUSI library.")
        return

    # Check if I2C is supported
    i2c_support = ctypes.c_uint32(0)
    status = dll.SusiBoardGetValue(0x00030100, ctypes.byref(i2c_support))  # SUSI_ID_I2C_SUPPORTED
    if status == 0:
        if i2c_support.value & 1:  # Check if the first bit (external I2C) is set
            print("External I2C is supported.")
        else:
            print("External I2C is not supported.")
    else:
        print("Failed to check I2C support.")

    # Uninitialize the SUSI library
    dll.SusiLibUninitialize()

if __name__ == "__main__":
    main()
<code end>

**Explanation:**

This code is very similar to the SMBus support check. The key difference is the use of `0x00030100` (`SUSI_ID_I2C_SUPPORTED`) to check for I2C support. 
